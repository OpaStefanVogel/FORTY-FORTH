<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="R00.xsl" ?>
<!DOCTYPE los SYSTEM "R00.dtd">
<los>

<step>Step 8</step>

<pr>Alles Multi

Mehrere Kopien des Forth-Prozessors werden zusammengeschaltet, um gemeinsam eine Matrix zu invertieren. Die Kopien werden ebenfalls in Matrixform verbunden, so dass jeder Prozessor einen linken, rechten, oberen und unteren Nachbar hat. Am linken Rand zählt als linker Nachbar der Prozessor vom gegenüberliegenden rechten Rand in der gleichen Zeile. Entsprechendes gilt auch für die anderen Ränder.

<object data="SVG_zu_R12.svg" width="550" height="260" />

Der Datenaustausch erfolgt über die Speicheradressen

Adresse   Datenbreite   Verwendung
2000-23FF     16        nach rechts schreiben, von links lesen
2400-27FF     16        nach unten schreiben, von oben lesen
2804           1        RECHTS-ABGESCHICKT, LINKS-ABGESCHICKT
2805           1        RECHTS-ANGEKOMMEN, LINKS-ANGEKOMMEN
2806           1        UNTEN-ABGESCHICKT, OBEN-ABGESCHICKT
2807           1        UNTEN-ANGEKOMMEN, OBEN-ANGEKOMMEN

Jeder FORTH-Prozessor kann im Adressbereich 2000H-23FFH Daten zum rechts daneben befindlichen Prozessor schicken und mit 

RECHTS-ANGEKOMMEN @ NOT RECHTS-ABGESCHICKT !

mitteilen, dass die zu übertragenden Daten komplett in den Adressbereich 2000H-23FFH gespeichert wurden. Der Prozessor rechts davon erkennt an LINKS-ABGESCHICKT ungleich dem zuletzt eingestellten LINKS-ANGEKOMMEN, dass neue Daten vorliegen und signalisiert nach dem Auslesen und Auswerten mit 

LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !

dass das Auslesen beendet ist und die nächsten Daten gesendet werden können. Entsprechsendes gilt auch für die Übertragungsrichtung von oben nach unten und den Adressbereich 2400H-27FFH.

Zu beachten ist, was in 2000H-27FFH gespeichert wird, kann nicht vom gleichen Prozessor zurückgelesen werden (um unnötige Verbindungen zu vermeiden) sondern nur vom Prozessor rechts oder unterhalb davon. Dieser wiederum kann diese Daten nur von 2000H-27FFH auslesen und nicht durch Zurückspeichern vorher nochmal verändern. Entsprechende Schreibversuche gehen dann weiter an den nächsten rechten oder unteren Prozessor.
</pr>

<p>Im Beispielprogramm wird wieder die gleiche Matrix invertiert wie in Step_11. Die Matrixein- und -ausgabe erfolgt vorerst noch behelfsmäßig durch vorheriges manuelle Aufteilen der Matrix auf die einzelnen Prozessoren und wieder Zusammensetzen nach dem Invertieren.

Neu sind das Eingabefile <i>test_input.txt</i> und das Ausgabefile <i>test_output.txt</i>. Dadurch ist es möglich, <i>vivado</i> auch ohne GUI im Modus <i>vivado -mode tcl</i> laufen zu lassen und das Ergebnis aus dem Ausgabefile zu lesen.</p>
 
<Terminal_1>
  <li> git checkout Step_12 </li>
  <li> git diff <diff>Step_12...Step_11</diff> </li>
  </Terminal_1>

<Tcl_Console>
  <li> close_sim -force -quiet </li>
  <li> launch_simulation </li>
  <li> run 200 ms </li>
  </Tcl_Console>

<DEMO>FORTY-FORTH

ok
<u>56 89 * .</u> 2E06 ok
<u>111111111111111 DUP * .</u> 123456789ABCDEFEDCBA987654321 ok
<u>DECIMAL</u> ok
<u>56 89 * .</u> 4984 ok
<u>[ [ 1   1   1    1 ]</u> ok
<u>  [ 2   4   8   16 ]</u> ok
<u>  [ 3   9  27   81 ]</u> ok
<u>  [ 4  16  64  256 ] ] </u> ok
<u>4 INVERTIEREN</u> 
<u>OVER .</u> [ [ 1152 -864 384 -72 ] [ -1248 1368 -672 132 ] [ 432 -576 336 -72 ] [ -48 72 -48 12 ] ] ok
<u>DUP .</u> 288 ok
</DEMO>

<svg_path schnips="1 1 -3 -100"/>
</los>
