( ------------------------------------------------------------- und hier beginnt FFINIT2.txt
<sekt inhalt="Variablen">
2F20 CONSTANT RAMP1 RAMP1 1+ RAMP1 ! ( bis 2F17 sind neu BASE TIB ... )
: VARIABLE RAMP1 @ DUP CONSTANT DUP 1+ RAMP1 ! ! ;
</sekt>

<sekt inhalt="noch paar hilfreiche Funktionen">
: MOVE ( adr1 adr2 n --> )
  BEGIN DUP WHILE ROT ROT OVER @ OVER ! SWAP 1+ SWAP 1+ ROT 1- REPEAT DROP 2DROP ;
: FILL ( adr n b --> )
  ROT ROT BEGIN DUP WHILE ROT ROT 2DUP ! 1+ ROT 1- REPEAT DROP 2DROP ;

: DUMP ( addr n --> )
  BEGIN SWAP ( CR DUP M. ) DUP @ M. 1+ SWAP 1- DUP 0= UNTIL 2DROP ;

: MAX ( a b --> c )
  2DUP LT IF SWAP END_IF DROP ;
: MIN ( a b --> c )
  2DUP > IF SWAP END_IF DROP ;
</sekt>

<sekt inhalt="Rechenoperationen zu verschiedenen Datentypen">
( leere Tabellenfelder sind nicht in Verwendung )
<table border="1">
  <tr><th>Rechenoperation</th>        <th>16-Bit-Arithmetik</th>        <th>große ganze Zahlen</th></tr>
  <tr><td>absoluter Betrag</td>       <td>ABS ( a --> |a| ) </td>       <td>ABS ( n --> |n| )</td></tr>
  <tr><td>Addition</td>               <td>M+ ( a b --> a+b ) </td>      <td>+ ( m n --> m+n ) </td></tr>
  <tr><td>Subtraktion</td>            <td>M- ( a b --> a-b ) </td>      <td>- ( m n --> m-n ) </td></tr>
  <tr><td>Stapelspitze ausgeben</td>  <td>M. ( a -->  /string/ )</td>   <td>. ( m -->  /string/ )</td></tr>
  <tr><td>Speicherinhalt ausgeben</td><td>M? ( adr -->  /string/ )</td> <td>? ( adr -->  /string/ )</td></tr>
  <tr><td>Addition mit Übertrag</td>  <td>U+ ( u a b --> u' a+b+u ) </td><td></td></tr>
  <tr><td>Multiplikation mit Übertrag</td><td>U* ( u a b --> u' a*b+u ) </td><td></td></tr>
  <tr><td>Inkrementieren</td>         <td>1+ ( a --> a+1 ) </td>        <td></td></tr>
  <tr><td>Dekrementieren</td>         <td>1- ( a --> a+1 ) </td>        <td></td></tr>
  <tr><td>kleiner als "&lt;"</td>     <td>LT ( a b --> a&lt;b )</td>    <td></td></tr>
  <tr><td>größer als</td>             <td>> ( a b --> a>b )</td>        <td></td></tr>
  <tr><td>Gleichheit</td>             <td>= ( a b --> a=b )</td>        <td></td></tr>
  <tr><td>Maximum</td>                <td>MAX ( a b --> max )</td>      <td></td></tr>
  <tr><td>Minimum</td>                <td>MIN ( a b --> min )</td>      <td></td></tr>
  <tr><td>Division mit Rest</td>      <td>M/MOD ( a b --> q r )</td>    <td>/MOD ( m n --> q r )</td></tr>
  <tr><td>Division</td>               <td></td>                         <td>/ ( m n --> q )</td></tr>
  <tr><td>Rest</td>                   <td></td>                         <td>MOD ( m n --> r )</td></tr>
  <tr><td>Multiplikation</td>         <td></td>                         <td>* ( m n --> m*n )</td></tr>
  <tr><td>größter gemeinsamer Teiler</td><td></td>                      <td>GGT ( m n --> ggt )</td></tr>
  <tr><td>Kürzen</td>                 <td></td>                         <td>BK ( m n --> m/ggt n/ggt )</td></tr>
  <tr><td>Potenzieren</td>            <td></td>                         <td>^ ( m n --> m^n )</td></tr>
  </table>
</sekt>

<sekt inhalt="Multiplikation">
A017 MCODE MULT_I
A018 MCODE MULT_II
: SUPERMULT ( a u adrc adrb n --> a u' adrc' adrb' )
  >R
  BEGIN MULT_I MULT_II UNTIL
  R> DROP ; ( /;> )





1401 CONSTANT A
1601 CONSTANT B
1801 CONSTANT C
A 1FF 1111 FILL
B 1FF 1111 FILL
C 3FF 0000 FILL

1111 0 C B 4 SUPERMULT M. M. M. M.
C 8 DUMP





: SMUL ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3)
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ M+ 1+
  L6 @ OVER 0 FILL
  L6 @ 
  DUP L2 @ L1 @ BEGIN
    0 2OVER @ ROT ROT L5 @ L4 @ ( ... a u  adrc  adrb n )
    SUPERMULT                   ( ... a u' adrc' adrb' )
    DROP ! DROP

(    vorher: )
(    L4 @ 0 
(    BEGIN OVER WHILE SWAP 1- SWAP
(      0 SWAP 
(      L6 @ @ L5 @ @ L2 @ @ U* D+ 
(      L6 @ DUP 1+ L6 ! !
(      L5 @ 1+ L5 !
(      REPEAT
(    L6 @ ! DROP

    ROT 1+ ROT 1+ ROT 1- ( 1 L2 +! 1 L6 +!
    DUP 0= UNTIL DROP 2DROP
  END_LOCAL
  ;

C 8 0 FILL
0 2 A 0 2 B C SMUL M. M. M.
C 8 DUMP

C 201 0 FILL
0 100 A 0 100 B C SMUL M. M. M.
C 8 DUMP

C 101 0 FILL
0 80 A 0 80 B C SMUL M. M. M.
C 8 DUMP

( C 2001 0 FILL
( 0 1000 A 0 1000 B C SMUL M. M. M.
( C 8 DUMP
</sekt>

<sekt inhalt="Addition"> 
: ADDIER ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 )
         ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L1 @ L4 @ MAX 1+ L6 @
  L0 @ L3 @ = IF
    0 L1 @ L4 @ MAX 0 BEGIN ROT
                 ( hier ist mal ! @ gewesen!!! )
      OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
      SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! ELSE 0 END_IF
      U+ L6 @ DUP 1+ L6 ! !
      ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP L6 @ !
    ELSE SWAP 1 M- SWAP
      1 L1 @ L4 @ MAX 0 BEGIN ROT
        OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
        SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! NOT ELSE -1 END_IF
        U+ L6 @ DUP 1+ L6 ! !
        ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP ( DUP M.
        0= IF DUP L6 !
          ROT NOT ROT ROT
          1 L1 @ L4 @ MAX 0 BEGIN ROT
            0 L6 @ @ NOT U+ 
            L6 @ DUP 1+ L6 ! !
            ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP DROP
          END_IF
      END_IF 
  END_LOCAL ;


C 8 0 FILL
0 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 5 A 0 7 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 7 A 0 3 B C ADDIER M. M. M.
C 8 DUMP

A 8 FFFF FILL
C 8 0 FILL
0 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP ( 1110 1111 0001 0000 )


A 8 2222 FILL
C 8 0 FILL
0 2 A -1 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
-1 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 2 B -1 2 A C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
-1 2 B 0 2 A C ADDIER M. M. M.
C 8 DUMP
</sekt>

<sekt inhalt="Division">
A014 MCODE DI32 
: DIV32 ( a b d --> r q )
  10 BEGIN >R DI32 R> 1- DUP 0= UNTIL 2DROP ;
: M/MOD ( b d --> r q ) 0 ROT ROT DIV32 ;



: SDIV ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 s4 l4 r4 )
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
L1 @ L4 @ LT IF L0 @ L1 @ L2 @ 0 0 0 ELSE
  L1 @ 0 BEGIN
    L2 @ OVER M+ @ NOT OVER L6 @ M+ !
    1+ 2DUP M- 0= UNTIL 2DROP
  L6 @ L1 @ M+ L4 @ M- L2 !
  -1 L6 @ L1 @ M+ ! 1 L1 +!
  L1 @ L4 @ M- 0 BEGIN
    L2 @ L4 @ M+ @ NOT
    L2 @ L4 @ M+ 1- @ NOT
    L5 @ L4 @ M+ 1- @      ( a b c )
    DIV32 
    SWAP DROP              ( q )
    DUP L2 @ L4 @ M+ 1+ !
    0 L2 @ L5 @ L4 @       ( c ü adrc adrb n )
    SUPERMULT
    2DROP SWAP DROP
    0 L2 @ L4 @ M+ @ U+ L2 @ L4 @ M+ !
BEGIN WHILE
 1 L4 @ 0 BEGIN ROT
   OVER L2 @ OVER M+ @
   SWAP L5 @ M+ @ NOT
   U+ SWAP >R OVER L2 @ M+ ! R>
   ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP
(   0 L2 @ L4 @ M+ @ U+ L2 @ L4 @ M+ !
(   DUP M. 7 EMIT
 -1 L2 @ L4 @ M+ 1+ +!
REPEAT
    -1 L2 +!
    1+ 2DUP M- 0= UNTIL 2DROP
  L4 @ 0 BEGIN
    L6 @ OVER M+ @ NOT OVER L6 @ M+ !
    1+ 2DUP M- 0= UNTIL 2DROP
  L4 @ L6 @ 1- !
  L1 @ L4 @ M- L6 @ L4 @ M+ !
( CR ." ++" L6 @ L1 @ 1+ DUMP ." ++"
  L0 @ L4 @ L6 @
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ M-
  L6 @ L4 @ M+ 1+
 END_IF
  END_LOCAL
  ;

( 333333 4 ^ 10 * VARIABLE NA
( 333333 DUP * 10 * VARIABLE NB
( NA @ 10 DUMP
( NA @ NB @ 2OPERANDEN->2SLX OVER M. DUP M. SDIV

654321 A !
234567 A 1+ !
000001 A 2 M+ !
432101 B !
A98765 B 1+ !

0 3 A 0 2 B C SMUL M. M. M.
C 8 DUMP

0 4 C 0 2 B A SDIV M. M. M. M. M. M.
A 8 DUMP
</sekt>

<sekt inhalt="Zahlenspeicher">
0 VARIABLE OPERAND1
0 VARIABLE OPERAND2
1800 VARIABLE ERGEBNIS
1800 VARIABLE ZAHLENSPEICHER
2000 VARIABLE SPEICHERENDE
0 VARIABLE SCHIEB

: TRIM ( sz lz az --> sz lz' az )
  SWAP 2DUP M+ 1- ( sz az lz ez 
  BEGIN OVER 0= NOT OVER @ 0= AND WHILE 
    SWAP 1- SWAP 1- REPEAT ( sz az lz' ez' )
  DROP SWAP ( sz lz' az )
  ;

1A01 20 0 FILL
1A01 11 7 FILL
0 20 1A01 TRIM ROT M. SWAP M. M.

: SLX->ERGEBNIS_KURZ ( sz lz az --> z )
  1-             ( sz lz az-1 )
  SWAP OVER !    ( sz az-1 )
  04 000 MLIT OR ( sz z ) 
  SWAP IF MINUS END_IF ( z )
  ;

: SLX->ERGEBNIS ( sz lz az --> z )
  OVER IF
    OVER 1 = ( falls lz=1 )
    OVER @ 0C 000 MLIT AND 0= AND ( und az@ kleiner 4000 )
    IF @ SWAP DROP SWAP IF MINUS END_IF 
      ELSE SLX->ERGEBNIS_KURZ END_IF ( z )
    ELSE 2DROP DROP 0 END_IF ( 0 zum Beispiel bei 1/7 )
  ;

0 11 1A01 SLX->ERGEBNIS M. ( 5A00 )
1A00 @ M. ( 0011 )

: OPERAND->SLX ( op --> sx lx ax )
  DUP @ ( op x )
  DUP 0LT IF MINUS -1 ELSE 0 END_IF
  ROT ROT ( sx op xabs )
  DUP 04 000 MLIT AND IF
    SWAP DROP
    3FFF AND
    DUP @ SWAP 1+
    ELSE
      OVER ! 1 SWAP 
      END_IF
  ;

77 OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.
-77 OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.
05 0800 MLIT OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.






: ERGEBNIS_NEU! ( ergneu --> )
  DUP SPEICHERENDE @ LT NOT IF 0369 ERROR END_IF
  ERGEBNIS ! ;

: SPEICHERHOL ( l --> addr )
  ERGEBNIS @ 2DUP !
  1+ 2DUP M+ ERGEBNIS_NEU!
  2DUP SWAP 0 FILL
  SWAP DROP
  ;

: 2OPERANDEN->2SLX ( op1 op2 --> sx lx ax sy ly ay az )
  OPERAND2 !
  OPERAND1 !
  OPERAND1 OPERAND->SLX
  OVER >R
  OPERAND2 OPERAND->SLX
  OVER R> M+ 1+
  SPEICHERHOL
  ;

77 88 2OPERANDEN->2SLX M. M. M. M. M. M. M.
77 05 0800 MLIT 2OPERANDEN->2SLX M. M. M. M. M. M. M.
</sekt>

<sekt inhalt="+ - * /MOD .">
: + ( x y --> z )
  2OPERANDEN->2SLX ADDIER TRIM SLX->ERGEBNIS ;
: - ( x y --> z )
  MINUS + ;
: * ( x y --> z )
  2OPERANDEN->2SLX SMUL TRIM SLX->ERGEBNIS ;


IMMEDIATE: RECURSE LFA @ 4 M+ COMPILE, ;
: /MOD ( x y --> r q )
  DUP 0= IF 0 ERROR END_IF
  DUP OPERAND1 !
  OPERAND1 OPERAND->SLX 
  ROT DROP OVER M+ 1- @ ( ly ty )
  SWAP 1 > IF
    1 BEGIN OVER 0LT NOT WHILE 
      SWAP DUP M+ SWAP DUP + REPEAT
    SWAP DROP DUP SCHIEB !
    ROT OVER *
    ROT ROT *
    ELSE DROP 1 SCHIEB ! END_IF 
  2OPERANDEN->2SLX SDIV
  TRIM SLX->ERGEBNIS >R 
  TRIM SLX->ERGEBNIS R>
  SCHIEB @ 1- IF 
    SWAP SCHIEB @ RECURSE SWAP DROP
    SWAP END_IF
  ;

: HG0. ( n -->  /hexstring/ )
  0 >R
  SHL16 DUP IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT ELSE DROP END_IF
  SHL16 DIG EMIT DROP R> DROP ;

: . ( n --> ) ( erstmal nur hexadezimale Ausgabe )
  OPERAND1 !
  OPERAND1 OPERAND->SLX ( sx lx ax )
  ROT IF ." -" END_IF
  OVER M+ 
  1- DUP @ HG0. SWAP 1- SWAP
  BEGIN OVER WHILE 1- DUP @ HG. SWAP 1- SWAP REPEAT DROP
  DROP 
  20 EMIT
  ;

1111 1111 * .

: B. SWAP . . ;



7 3 /MOD . . 
3333 DUP * DUP * 10 * DUP .
3333 DUP * 10 * DUP .
/MOD B.
3333 DUP * .

1111 DUP * 8 * DUP .
1111 8 * DUP .
/MOD B.

1111 DUP * DUP .
1111 DUP .
/MOD B.
</sekt>

<sekt inhalt="Zwischenergebnisse nicht unnötig speichern">
ZAHLENSPEICHER @ VARIABLE BLOCKANFANG
ZAHLENSPEICHER @ VARIABLE BLOCKENDE
: NEBENRECHNUNG ( --> erg ) ERGEBNIS @ ;
: HAUPTRECHNUNG ( erg --> ) ERGEBNIS ! ;
: RECHENBLOCK BLOCKENDE @ BLOCKANFANG !
  ERGEBNIS @ BLOCKENDE ! ;
: INIT ZAHLENSPEICHER @ ERGEBNIS ! RECHENBLOCK RECHENBLOCK ;
INIT
ERGEBNIS M?

: A+0 ( a --> a+0 ) 
  DUP OPERAND1 !
  OPERAND1 OPERAND->SLX ( a sz lz az )
  DUP OPERAND1 M- IF
    ERGEBNIS @ 1+ SWAP OVER 2OVER ( a sz lz erg+1 az erg+1 lz erg+1 )
    OVER M+ ERGEBNIS_NEU!         ( a sz lz erg+1 az erg+1 lz )
    MOVE SLX->ERGEBNIS_KURZ       ( a a+0 )
    SWAP DROP                     ( a+0 )
    ELSE 2DROP DROP END_IF        ( a+0 )
  ;

05 0A00 MLIT A+0 M.

: B+0 ( a b --> a+0 b+0 )
  SWAP A+0 SWAP A+0 ;
</sekt>



<sekt inhalt="Anwenden in + - * / MOD GGT BK...">
: + ( x y --> z ) NEBENRECHNUNG ROT ROT + SWAP HAUPTRECHNUNG A+0 ;
: - ( x y --> z ) NEBENRECHNUNG ROT ROT - SWAP HAUPTRECHNUNG A+0 ;
: * ( x y --> z ) NEBENRECHNUNG ROT ROT * SWAP HAUPTRECHNUNG A+0 ;
: / ( b d --> q )
  NEBENRECHNUNG ROT ROT 
  /MOD SWAP DROP
  SWAP HAUPTRECHNUNG A+0
  ;
: MOD ( b d --> r ) 
  NEBENRECHNUNG ROT ROT 
  /MOD DROP 
  SWAP HAUPTRECHNUNG A+0
  ;

: GGT ( a b --> ggt )
  NEBENRECHNUNG ROT ROT
  BEGIN DUP WHILE
    SWAP OVER MOD REPEAT DROP 
  SWAP HAUPTRECHNUNG A+0 ;
: BK ( a b --> a/ggt b/ggt ) 
  NEBENRECHNUNG ROT ROT
  2DUP GGT ROT OVER / ROT ROT / 
  ROT HAUPTRECHNUNG B+0 ;



777 99 BK B.




( je einmal * und + in NNUMBER )
: NNUMBER ( baddr n --> a faddr )
  NEBENRECHNUNG ROT ROT
  7 LOCAL ( L3 L4 nicht verwendet
  L1 ! L0 !
  0 L1 @ IF
    DUP L2 ! 1 L5 ! ( Vorzeichen )
    BEGIN ( M23 Vorzeichen gucken )
      -1 L6 ! 
      L0 @ L2 @ M+ C@
      2B ( 43 2B ) = IF L2 @ 1+ L2 ! 0 L6 ! ELSE
        L0 @ L2 @ M+ C@
        2D ( 45 2D ) = IF L2 @ 1+ L2 !
          0 L6 !
          L5 @ MINUS L5 ! END_IF
        END_IF
      L6 @ UNTIL
    L2 @ L1 @ LT IF
      BEGIN
        L0 @ L2 @ M+ C@
        DUP IF ( oo L1 auf Bytes )
          DIGIT NOT IF DROP L1 @ MINUS L1 ! ELSE
            SWAP BASE @ * +
            L2 @ 1+ L2 ! 
            END_IF
          ELSE DROP L2 @ L1 ! END_IF
        L2 @ L1 @ LT NOT UNTIL
      END_IF ( M19 )
    END_IF ( M19 )
  L5 @ 0LT IF MINUS END_IF
  L2 @ L1 @ M- ( oo noch kein fadr !!!!!!!!!!!! siehe NNUMBER )
  DUP IF DROP L0 @ L2 @ M+ END_IF ( jetzt faddr )
  END_LOCAL
  ROT HAUPTRECHNUNG SWAP A+0 SWAP
  ;

( zum Testen erst nur Zahleneingabe mit N" )
22 WORD: N" ( /number/  --> n ) NNUMBER DROP ;

N" 111111111111111" DUP * DUP . DUP M.
N" 111111111111111" DUP . DUP M.
/MOD OVER M. DUP M. B.

N" 0026D4346A00" DUP .
N" 00000FC82800" DUP .
2DUP /MOD B.
2DUP BK B. 
( richtig wäre D6A2200 275 bei /MOD )
( richtig wäre 3135 14 bei BK )

N" 00A7426290A8C945E959A780" DUP .
N" 000002330657FDD698" DUP .
/MOD B. 
( richtig wäre 158B5843D5ED0 4C0CF598D2 )
( und nicht   0325AF2C3F8838 4C0CF598D3 )

( als vorlaeufigen Abschluss nochmal )
" 111111111111111" NNUMBER DROP DUP * .

N" 000002330657FDD698" N" 4C0CF598D3" * .
N" 000002330657FDD698" N" 4C0CF598D2" * .


( wenn alles so geht, kann es richtig losgehen )<id id="NNUMBER"/>
: REPLACE: ( /name/ ) 
  CSP! ( oo )
  20 WORD FIND DUP IF 
    LCFA DROP 1+ ( pfa
(    HERE OVER M- 1- JRBIT XSETBT SWAP !
    HERE SWAP DP ! DUP COMPILE, RETURN , DP !
    1 STAT !
    ELSE 2DROP 3 ERROR END_IF ;

REPLACE: NUMBER NNUMBER ;
111111111111111 DUP * .



: ^ ( a n --> a^n )
  NEBENRECHNUNG ROT ROT ( erg a n )
  4 LOCAL
  DUP 0LT IF 12 ERROR END_IF    
  2           ( a n 2 )        
  L3 ! L2 ! L1 !    (  R1-3: a  n  2 )
  1           ( p=1          a  n  2 )
  BEGIN       ( p            a  n  2 )
    L2 @ L3 @ ( p n 2        a  n  2 )
    M/MOD     ( p r n/2      a  n  2 )
    L2 !      ( p r          a n/2 2 )
    IF        ( p            a n/2 2 )
      L1 @    ( p a          a n/2 2 )
      *      ( p*a          a n/2 2 )
      END_IF  ( p*a          a n/2 2 )
    L2 @      ( p*a n/2      a n/2 2 )
    WHILE     ( p*a          a n/2 2 )
      L1 @    ( p*a a        a n/2 2 )
      L1 @    ( p*a a a      a n/2 2 )
      *      ( p*a a*a      a n/2 2 )
      L1 !    ( p*a        a*a n/2 2 )
      REPEAT  ( p*a        a*a n/2 2 )
  END_LOCAL   ( a^n )
  SWAP HAUPTRECHNUNG A+0
  ;           ( a^n )


3333 2 ^ 10 * .
1111 2 ^ .


10 20 ^ 10 10 ^ DUP -1 + SWAP 1 + * - .
</sekt>

<sekt inhalt="nochmal . für beliebige Zahlenbasis">
: . ( a -->  /zahl/ )
  BASE @ 10 = IF . ELSE
    NEBENRECHNUNG SWAP
    DUP 0LT IF MINUS ." -" END_IF
    DUP 0= IF ." 0 " DROP ELSE
      -1 SWAP ( Stapelmarkierung )
      BEGIN DUP WHILE BASE @ /MOD REPEAT DROP
      BEGIN DUP 0LT NOT WHILE 30 M+ DUP 39 > IF 7 M+ END_IF EMIT REPEAT
      20 EMIT DROP END_IF
    HAUPTRECHNUNG
    END_IF
  ;
: B. SWAP . . ; ( muss hier nochmal stehen )

777 99 BK B.
INIT
</sekt>

<sekt inhalt="Array-Objekte">
: ZERLEG ( a --> adr i )
  3FFF AND DUP 1+ SWAP @ ;

N" 111111111111111" DUP * DUP .
DUP ZERLEG SWAP M. M.

: OBJ? ( a --> flag )
  ABS DUP 04 000 MLIT LT IF DROP 0 ELSE
    ZERLEG SWAP DROP 04 000 MLIT LT IF 0 ELSE -1 
      END_IF END_IF
  ;

: L ( a i -> b ) OVER OBJ? IF
    SWAP ZERLEG 3FFF AND ( i adr j )
    ROT 2DUP ( adr j i j i )
    > IF SWAP DROP M+ @ ELSE 2DROP DROP 0 END_IF
    ELSE IF DROP 0 END_IF END_IF ;

: G ( a i -> a i b ) 2DUP L ;

: H ( a i b --> a' )
  DUP >R
  ROT ROT ( b a i )
  OVER OBJ? 0= OVER 0= AND R> OBJ? 0= AND IF 2DROP ELSE
    OVER OBJ? 0= IF 
      DUP 1+ SPEICHERHOL ( b a i addrneu )
      ROT OVER ! ( b i addrneu )
(      OVER 1+ OVER 1- ! ( b i addrneu ( aha, macht schon SPEICHERHOL )
      04 000 MLIT OVER 1- +! ( das ist jetzt neu fuer OBJ? )
      DUP >R M+ ! R> ( addrneu )
      1- 04 000 MLIT OR
      ELSE
        OVER                 ( b a i a )
        ZERLEG 3FFF AND      ( b a i addr j )
        ROT                  ( b a addr j i )
        2DUP > IF SWAP DROP ROT >R M+ ! R> ELSE
          DUP 1+ SPEICHERHOL ( b a addr j i addrneu )
          SWAP >R DUP >R     ( b a addr j addrneu      addrneu i )
          SWAP MOVE DROP R>  ( b addrneu            i )
(          R 1+ OVER 1- !    ( b addrneu                i )
          04 000 MLIT OVER 1- @ OR OVER 1- !   ( das ist jetzt neu fuer OBJ? )
          SWAP OVER R> M+ !  ( addrneu )
          1- 04 000 MLIT OR  ( a' )
          END_IF
        ZERLEG 3FFF AND      ( adr l )
        BEGIN 2DUP M+ 1- @ 0= OVER 1 > AND WHILE 1- REPEAT ( adr lneu )
        OVER @ OBJ? 0= OVER 1 = AND IF DROP @ ELSE
          SWAP 1- SWAP       ( addr-1 lneu )
          04 000 MLIT OR OVER ! 04 000 MLIT OR
          END_IF  
        END_IF
    END_IF
  ;
  
: . ( obj --> )
  DUP OBJ? IF
    ." [ "
    ZERLEG 3FFF AND OVER M+ SWAP ( eadr+1 aadr )
    BEGIN 2DUP > WHILE DUP @ RECURSE 1+ REPEAT 2DROP
     ." ] "
    ELSE . END_IF
  ;
: B. SWAP . . ; ( und hier nochmal )

7 DUP .
2 9 H DUP .
3 11 H DUP .
1 4 1 6 H H DUP .
1 G 2 88 H H DUP . 
1 G 2 0 H H DUP .
0 G 2 1987 H H DUP .
1 0 H DUP .
3 0 H DUP .
2 0 H DUP .
2 2444 H DUP .
0 7777777 H DUP .
2 0 H DUP .


0
0 0 0 1 H 1 2 H 2 5 H H DUP .
1 0 0 3 H 1 4 H 2 8 H H DUP .
2 0 0 9 H 1 2 H 2 1 H H CR DUP .

0 1 4 H DUP .
0 0 0 1 4 H H .

0 
0 0 0 60 H 1 30 H 2 20 H H DUP .
1 0 0 30 H 1 20 H 2 15 H H DUP .
2 0 0 20 H 1 15 H 2 12 H H CR DUP .

0 VARIABLE SPMERK
: [ ( ---> spmerk )
  SPMERK @ SP @ SPMERK !
  ;

: ] ( spmerk a b c d ... z --> matrix )
  0 BEGIN SP @ 1- SPMERK @ M- WHILE
    SP @ 2 M- SPMERK @ M- ROT H REPEAT
  SWAP SPMERK !
  ;
</sekt>

<sekt inhalt="Matrix invertieren">
: OBJ+0 ( obj --> obj+0 )
  DUP OBJ? IF DUP >R
    ZERLEG 3FFF AND          ( adr n )
    SWAP OVER M+ 1- SWAP     ( eadr-1 n )
      BEGIN DUP WHILE SWAP   ( n eadr-1 )
        DUP @ RECURSE OVER ! ( n eadr-1 )
        1- SWAP 1-           ( eadr-1 n-1 )
        REPEAT               ( adr-1 0 )
    2DROP R>                 ( obj )
    ELSE A+0 END_IF
  ;

[ 12 18 1B ] OBJ+0 .

: OBJDUMP ( obj --> )
  DUP OBJ? IF
    ZERLEG 3FFF AND                ( adr n )
      BEGIN DUP WHILE SWAP         ( n adr )
        CR OVER M. DUP M. DUP @    ( n adr a )
        DUP M. DUP ABS 3FFF > NOT IF -1 M. -1 M.
          ELSE DUP ABS ZERLEG M. M. END_IF
        DUP . RECURSE              ( n adr )
        1+ SWAP 1-                 ( adr+1 n-1 )
        REPEAT                     ( adr+n 0 )
    2DROP                          ( )
    ELSE DROP END_IF
  ;

[ 12 18 1B ] OBJDUMP
[ [ 12 18 1B ] [ 1E 21 24 ] ] OBJDUMP

: OBJ_STRUCT_COPY ( obj --> copy )
  DUP OBJ? IF
    ERGEBNIS @ 04 000 MLIT OR SWAP   ( copy obj )
    ZERLEG DUP ERGEBNIS @ ! 3FFF AND ( copy adr n )
    ERGEBNIS @ 1+ SWAP               ( copy adr erg+1 n )
    2DUP M+ ERGEBNIS_NEU!            ( copy adr erg+1 n )
    ROT ROT BEGIN                    ( copy n adr erg+1 )
      OVER @ RECURSE OVER !          ( copy n adr erg+1 )
      ROT 1- DUP WHILE               ( copy adr erg+1 n-1 )
        ROT 1+ ROT 1+ REPEAT         ( copy n-1 adr+1 erg+2 )
    2DROP DROP                       ( copy )
    ELSE A+0 END_IF
  ;

[ 111 222 333 ] DUP M. OBJ_STRUCT_COPY M.
[ [ 1  1 ] [ 3 2 ^ 3 4 ^ ] ] DUP M. OBJ_STRUCT_COPY M.

: SIZE ( obj --> n )
  ZERLEG SWAP DROP 3FFF AND ;

: ADEBUG1 CR CR ." ADEBUG1 " >R 2OVER B. 2DUP B. R> DUP . -1 2D04 ! ;
: ADEBUG2 CR CR ." ADEBUG2 " 0 2D04 ! OVER . DUP . ;
: [A*x-Y*Z]/gx ( A gx x Y Z --> A' x )
  ( L0=nr L1=Nj L2=Nk L3=j L4=k L5=Y L6=Z L7=alternenner )
  8 LOCAL NEBENRECHNUNG L0 !
  ADEBUG1
  OVER SIZE L1 ! DUP SIZE L2 !
  L6 ! L5 ! SWAP L7 !
  L1 @ L3 ! BEGIN -1 L3 +!
    OVER L3 @ L ( mat nenner mat[L3] )
    L2 @ L4 ! BEGIN -1 L4 +! ( CR L3 M? L4 M? ERGEBNIS M?
      NEBENRECHNUNG ROT ROT SWAP ( mat erg mat[L3] nenner )
      OVER L4 @ L OVER *
      L5 @ L3 @ L L6 @ L4 @ L * -
      L7 @ / ( mat erg mat[L3] nenner bijneu )
      2SWAP SWAP ( mat nenner bijneu mat[L3] erg )
      HAUPTRECHNUNG SWAP A+0 ( mat nenner mat[L3] bijneu+0 )
      SWAP L4 @ ROT H ( mat nenner mat[L3]neu )
      L4 @ 0= UNTIL
    ROT L3 @ ROT H SWAP ( matneu nenner )
    L3 @ 0= UNTIL
  A+0 ( verschiebt nenner hinter matneu )
  L0 @ HAUPTRECHNUNG SWAP OBJ+0 SWAP A+0 ( A' x )
  END_LOCAL ADEBUG2
  ;

( DECIMAL
( [ [ 1   1   1    1 ]
(   [ 2   4   8   16 ]
(   [ 3   9  27   81 ]
(   [ 4  16  64  256 ] ] 1 SP ?
( 1 [ 2 2 3 4 ] [ 0 1 1 1 ] [A*x-Y*Z]/gx OVER . DUP . 
( [ [ 1 -1 -1 -1 ] [ 2 2 6 14 ] [ 3 6 24 78 ] [ 4 12 60 252 ] ] 1 ok
( 2 [ -1 3 6 12 ] [ 2 1 6 14 ] [A*x-Y*Z]/gx OVER . DUP . 
(  [ [ 4 -1 4 12 ] [ -2 1 -6 -14 ] [ -6 6 12 72 ] [ -16 12 48 336 ] ] 2 ok
( 12 [ 4 -6 14 48 ] [ -6 6 10 72 ] [A*x-Y*Z]/gx OVER . DUP . 
( [ [ 36 -18 4 -72 ] [ -30 24 -6 132 ] [ 6 -6 2 -72 ] [ 48 -72 48 288 ] ] 12 140 ok
( 288 [ -72 132 -72 300 ] [ 48 -72 48 276 ] [A*x-Y*Z]/gx OVER . DUP . 
(  [ [ 1152 -864 384 -72 ] [ -1248 1368 -672 132 ] [ 432 -576 336 -72 ] [ -48 72 -48 12 ] ] 288 ok

: INVERTIEREN ( matrix dim --> invmat nenner ) <h href="INVERTIEREN.xml" />
  ( L0=nr L1=N L2=i L3=j L4=k L5=Y L6=Z L7=alternenner )
  8 LOCAL NEBENRECHNUNG L0 !
  L1 ! 1 ( mat nenner )
  L1 @ L2 ! BEGIN -1 L2 +! ( CR L2 M? ERGEBNIS M?
    L7 ! ( mat ) 0 L5 ! 0 L6 !
    DUP L2 @ L L2 @ L ( mat neuernenner )
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L L2 @ L L5 @ L3 @ ROT H L5 !
      OVER L2 @ L L3 @ L L6 @ L3 @ ROT H L6 !
      L3 @ 0= UNTIL
    L5 @ L2 @ L L7 @ + L5 @ L2 @ ROT H L5 !
    L6 @ L2 @ L L7 @ - L6 @ L2 @ ROT H L6 !
    L7 @ SWAP L5 @ L6 @ [A*x-Y*Z]/gx
    L2 @ 0= UNTIL
  END_LOCAL
  ;

( so und jetzt anwenden )

[ [ 3C 1E 14 ] ( dezimal 60 30 20 )
  [ 1E 14 0F ] ( dezimal 30 20 15 )
  [ 14 0F 0C ] ( dezimal 20 15 12 )
  ] 3
OVER . DUP M.
INVERTIEREN
OVER . DUP .
( herauskommen muss dabei )
(             [ [ F -3C 32 ] [ -3C 140 -12C ] [ 32 -12C 12C ] ] 64 )
( dezimal        15 -60 ...                                      100 )


( paar Vandermonde-Matrizen invertieren: )
INIT
[ [ 1 1 1 1 ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ ]
  ]
4 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 480 -360 180 -48 ] [ -4E0 558 -2A0 84 ] ... ] 120 )

INIT
[ [ 1 1 1 1 1 ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ 2 5 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ 3 5 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ 4 5 ^ ]
  [ 5 1 ^ 5 2 ^ 5 3 ^ 5 4 ^ 5 5 ^ ]
  ]
5 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll  [ [ 2A300 -2A300 ... ] ] 8700 )

: VANDERMONDEMATRIX ( n --> mat )
  3 LOCAL
  L0 !
  0 
  L0 @ L1 ! BEGIN L1 @ DUP WHILE 1- L1 !
    L1 @ G
    L0 @ L2 ! BEGIN L2 @ DUP WHILE 1- L2 !
      L2 @ L1 @ 1+ L2 @ 1+ ^ 
      H
      REPEAT DROP
    H
    REPEAT DROP
  END_LOCAL
  ;

( 4 VANDERMONDEMATRIX DUP .

INIT
4 VANDERMONDEMATRIX
4 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 480 -360 180 -48 ] [ -4E0 558 -2A0 84 ] [ 1B0 -240 150 -48 ] [ -30 48 -30 C ] ] 120
( gekürzt [ [ 60 -48 20 -6 ] [ -68 72 -38 B ] [ 24 -30 1C -6 ] [ -4 6 -4 1 ] ] 18 ok

INIT
5 VANDERMONDEMATRIX
5 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 2A300 -2A300 1C200 -A8C0 1B00 ] [ -36240 4B3C0 -36D80 15720 -3840 ] [ 18F60 -297C0 22740 -E6A0 2760 ] [ -4EC0 9240 -8700 3DE0 -B40 ] [ 5A0 -B40 B40 -5A0 120 ] ] 8700
( gekürzt [ [ 258 -258 190 -96 18 ] [ -302 42E -30C 131 -32 ] ... [ 5 -A A -5 1 ] ] 78 ok

INIT
6 VANDERMONDEMATRIX
6 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 8E62000 -B1FA800 9E34000 ... -32A00 8700 ] ] 17BB000
( gekürzt [ [ -10E0 1518 -12C0 A8C -360 78 ] ... [ 6 -F 14 -F 6 -1 ] ] -2D0 ok

INIT
7 VANDERMONDEMATRIX
ERGEBNIS M?
7 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ CC65AF0000 -13298868000 ... 17BB000 ] ] 1D33190000 
( gekürzt [ [ -89D0 CEB8 -E5B0 AC44 -52B0 16F8 -2D0 ]  ... [ -7 15 -23 23 -15 7 -1 ] ] -13B0 ok

INIT
8 VANDERMONDEMATRIX
ERGEBNIS M?
( 8 INVERTIEREN ( nicht mehr wegen [A*x-Y*Z]/gx in INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 8FB77F0C000000 -FB811E55000000 ... 1D33190000 ] ] 11F6EFE1800000
( gekürzt [ [ 4EC00 -89D00 B7C00 -AC440 6E400 -2DF00 B400 -13B0 ] ... [ -( 1C -38 46 -38 1C -8 1 ] ] 9D80 ok

INIT
9 VANDERMONDEMATRIX
ERGEBNIS M?
( 9 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 37F3F5B381040000000 ... 11F6EFE1800000 ] ] 6378D13F1E40000000
( gekürzt [ [ 31D580 -63AB00 9B0A00 -AE6B40 8B8900 -4D8500 1C7A00 -63AB0 9D80 ] ... [ 9 -24 54 -7E 7E -54 24 -9 1 ] ] 58980 ok

INIT
0A VANDERMONDEMATRIX
ERGEBNIS M?
( 0A INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ D726B3E61B37C18000000000 ... 6378D13F1E40000000 ] ] 1583DECA35EBF9C000000000
( gekürzt [ [ -229B600 4DDD980 -8A6D800 B5AFB80 ... -D2 78 -2D A -1 ] ] -375F00 ok

INIT
0B VANDERMONDEMATRIX
ERGEBNIS M?
( 0B INVERTIEREN OVER . DUP . ERGEBNIS M?
( herauskommen soll [ [ 2331530F3797CA8619C400000000000 -57FB4FA60AFB7A4F406A00000000000 ... 1583DECA35EBF9C000000000 ] ] 333078D050DCC97D3CC00000000000
( gekürzt [ [ -1A2BE700 416DC180 -82DB8300 ... -14A A5 -37 B -1 ] ] -2611500 ok

INIT
0C VANDERMONDEMATRIX
ERGEBNIS M?
( 0C INVERTIEREN OVER . DUP . ERGEBNIS M?
( herauskommen soll 
( OVER . DUP . [ [ 1569BD000 -3AE2C7C00 82DB83000 ... -318 1EF -DC 42 -C 1 ] ] 1C8CFC00 ok

( mehr geht erstmal nicht weil nicht mehr Platz )


INIT
[ [ 112  431  199 764 987 434 ]
  [ 543 45 33 41 789 566 ]
  [ 543 145 33 42 789 566 ]
  [ 875 687 098 675 677 574 ]
  [ 875 66B 0987 675 678 634 ]
  [ 454 33 555 934 655 633 ]
  ] 
DUP .
6 INVERTIEREN ( mat dim --> invmat nenner )
OVER .
DUP .
</sekt>

<sekt inhalt="Reste die auch weggelassen werden können, wenn alles geht">
: VLIST
  LFA @ BEGIN 
    DUP 1+ @ OVER 2 M+ @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ M+ REPEAT
  DROP ;

: WLIST
  LFA @ BEGIN ( CR ) DUP M.
    DUP 1+ @ OVER 2 M+ @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ M+ REPEAT
  DROP
  ;

: FORGET ( /name/ )
  20 WORD FIND IF 
    DP !
    HERE DUP @ M+ LFA !
    HERE 1+ @ BZEIG !
    ELSE DROP ." nicht gefunden " END_IF
  ;

: FEHLERTEXT ( n --> n )
  CR
  DUP 0 = IF ." Division durch Null" END_IF
  DUP 3 = IF ." Wort nicht definiert" END_IF
  DUP 6 = IF ." Eingabezeile zu lang" END_IF
  DUP 9 = IF ." Strukturfehler in IF END_IF BEGIN UNTIL DO LOOP " END_IF
  DUP 12 = IF ." negativer Exponent" END_IF
  DUP 369 = IF ." Zahlenspeicher voll" END_IF
  DUP 1234 = IF ." große ganze Zahlen kompilieren geht momentan nicht." END_IF
  ;

( ganz neu: Steuerungstasten: ^A bis ^G, weiter ^H=^A ^L=^B ... )
2F18 8 0 FILL
: STRG: : HERE 3 M- DUP M. @ 1+ DUP M. @ DUP M. 40 M- HERE SWAP 7 AND 2F18 M+ ! ;
STRG: ^G 7 EMIT ." /1xPIEP/" ;
STRG: ^F 7 EMIT ." QUIT" QUIT ;
STRG: ^A ." Angehalten für genau eine Eingabezeile: "
  CR 3A00 100 EXPECT INTERPRET ." ok";

: QUERY ( adr --> n ) TIB @ 100 EXPECT ;

IMMEDIATE: (*REM*) 
  3C EMIT ." /ok>"
  BEGIN CR QUERY " (*END*)" Z= UNTIL
  3C EMIT ." ok>"
  ;
</sekt>

<sekt inhalt="Reste, die schon weggelassen sind">
(*REM*)

( - LOOP's - sind aber sehr langsam )
: I RP @ 1+ @ ;
: J RP @ 3 M+ @ ;
: K RP @ 5 M+ @ ;
: (DO) SWAP R> ROT ROT >R >R >R ;
: (LOOP) R> R> 1+ DUP R LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R ;
: (+LOOP) R> R>  ROT DUP  0LT IF M+ R OVER
  ELSE M+ DUP R END_IF LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R  ;
IMMEDIATE: DO COMPILE (DO) HERE ;
IMMEDIATE: LOOP COMPILE (LOOP) 0BRANCH, ;
IMMEDIATE: +LOOP COMPILE (+LOOP) 0BRANCH, ;
( : LL 0 DO I M. LOOP ; 7 LL ( ok geht )


IMMEDIATE: () 0 WORD 2DROP ;
: B. ( a b --> ) SWAP M. M. ;

: LDUMP LFA @ HERE OVER M- DUMP ;

A012 MCODE D+
A013 MCODE D-


( - paar Geraeteadressen: )
D004 CONSTANT UHR
D005 CONSTANT SWTI
D00D CONSTANT UHRL
2D05 CONSTANT XOFFINPUT


: DABS ( h l --> h' l' )
  OVER 0LT IF 0 0 2SWAP D- END_IF ;


( CASEOFS aus'm PSION: )
: CASEOFS ( n  /name/ --> )
  DUP RAMBUF
  0 DO
    0 I RAMP3 @ + !
    LOOP
  ;

: CASEOF: ( fn en --> )
  M+ HERE DPMERK @ M- SWAP !
  CSP! 1 STAT !
  ;

: CASEOF ( fn en --> )
  M+ @ DUP IF
    DPMERK @ M+ EXECUTE
    ELSE DROP END_IF ;

( - CASE )
( : BIT ( i n --> bit )
(   2 ROT DUP 0LT IF 99 ERROR ELSE 
(   ^ AND 0= 1+ END_IF ; 

: (OF) ( n r i --> f r' )
  ROT = DUP ROT OR ;
: (RANGE-OF) ( n1 n2 r i --> f r' )
  DUP >R ROT > ROT R> > OR 0= DUP ROT OR ;
( : (BIT-OF) ( n r i --> f r' )
(   ROT BIT DUP ROT OR ;

IMMEDIATE: CASE ( n --> )
  " >R 0 >R" 
  INTERPRET ;
IMMEDIATE: END_CASE ( --> )
  " R> R> 2DROP" 
  INTERPRET ;
IMMEDIATE: OF ( n --> )
  " R> R (OF) >R IF" 
  INTERPRET ;              
IMMEDIATE: RANGE-OF ( n1 n2 --> )
  " R> R (RANGE-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: BIT-OF ( m --> )
  " R> R (BIT-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: ELSEOF ( --> )
  " R 0= IF" INTERPRET ;
IMMEDIATE: END_OF ( --> )
  " END_IF" INTERPRET ;
: ERR ." keine gültige RAM-Adresse" QUIT ;
' ERR 4000 OR 22 !
' ERR 4000 OR 20 !

IMMEDIATE: /; 0 STAT ! CSP? HERE 1- @ 800 OR HERE 1- ! SMUDGE [ SMUDGE ] ; 
( : T 77 88 DROP /; 
( ' T 8 DUMP
( : W PAUSENBIT ! /;
( ' W 8 DUMP


( Ausgabe von ESCAPE-Sequenzen: sie vertragen sich aber nicht mit xml, besser CSI nehmen )
20 WORD: ESC 1B EMIT BEGIN OVER C@ EMIT SWAP 1+ SWAP 1- DUP 0= UNTIL DROP ;
ESC ]0;FORTY-FORTH 07 EMIT ( 07 EMIT schließt ]
: FESTPOSITION ESC [s ESC [1;1H ESC [31m ; ( saveC Pos1,1 redcolor
: RUCKPOSITION ESC [u ESC [39m ; ( restoreC defaultcolor

( Alternativer Start mit ESCAPE-Sequenzen )

: QUIT2 
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ESC [34m ." ok" END_IF CR ESC [39m 
    TIB @ 100 EXPECT ESC [36m INTERPRET 
    AGAIN ;

( REPLACE: QUIT QUIT2 ;
( QUIT

: QUIT3
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ."   " END_IF
    CR  
    CRBIT @ 2 AND IF 3C EMIT ." /ok>" END_IF
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 36 EMIT 6D EMIT END_IF
    TIB @ 100 EXPECT 
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 39 EMIT 6D EMIT END_IF
    CRBIT @ 2 AND IF 3C EMIT ." ok>" END_IF
    INTERPRET
    AGAIN ;


: IOSTART
  2C40 2C00 DO I @ I ! LOOP
  2D30 2D14 DO I @ I ! LOOP
  ;
IOSTART

( wozu das RBIT war? für relatives CR )
: COMPILE, ( adr --> )
  RBIT @ IF 4000 ELSE 
    DP @ 1+ M- 0FFF AND 3000 END_IF
    0000 M+ M+ , ;

: a*a;; 
  A 2000 111111 FILL
  B 2000 111111 FILL
  C 4001 000000 FILL
  0 2000 A 0 2000 B C SMUL 7 EMIT ;
(*END*)
</sekt>

<sekt inhalt="DEMO">
56 89 M* M.
77 88 M+ M.

( aktuelles Vokabular

VLIST

( nochmal mit Speicheradressen, vor jedem Wort steht dessen "Linkfeld"_Adresse=Aufruf_Adresse-4 )

WLIST

( LED's zum Leuchten bringen, also auf Adresse 2D04 ausgeben )

2D04 CONSTANT LEDS
55 LEDS !

( erreichte Programmdresse in 0000-1FFF )

HERE M.

( erreichte Adresse in Textspeicher 3000-3FFF )

BZEIG M?

( aktuelle Stapelhoehe )

SP M?

( Ein neues Wort definieren )

: H ." Hallo Welt " ;

H

( Bedingung IF )

: W ( n --> ) 
  ." Das ist eine " 
  1 AND IF ." un" END_IF 
  ." gerade Zahl " ; 

7 W
8 W

( Programmschleifen, die für DO LOOP ist aber momentan stillgelegt. )

( : X ( n --> )
(   0 DO I M. LOOP ;
( 13 X 

( oder )

: Y ( n --> )
  0 BEGIN DUP M. 1+ 2DUP = UNTIL 2DROP ;

13 Y

( oder )

: Z ( n --> )
  0 BEGIN 2DUP > WHILE DUP M. 1+ REPEAT 2DROP ;

13 Z

( alles ab LEDS wieder vergessen )

HERE M. BZEIG M?
FORGET LEDS
HERE M. BZEIG M?


( ERGEBNIS bezeichnet, ab welcher Adresse das nächste Ergebnis gespeichert wird,
( Platz dafür ist von ZAHLENSPEICHER @ bis 1 vor SPEICHERENDE @, aktuell erreicht: )
 
ERGEBNIS M? ( Zahlenspeicher gefuellt bis ) 

ZAHLENSPEICHER @ ERGEBNIS ! ( Zahlenspeicher leeren )

ERGEBNIS M?

111111111111111 DUP * .

ERGEBNIS M?

( dritte binomische Formel 10^20-{10^10+1}*{10^10-1}=1 )
10 20 ^ 10 10 ^ 1 - 10 10 ^ 1 + * - .

ERGEBNIS M?


( Zahlenbasis wechseln )

: HEX 10 BASE ! ;
: DECIMAL 0A BASE ! ;

HEX 10000
DECIMAL DUP .
HEX DUP .

HEX 100000000
DECIMAL DUP .
HEX DUP .
</sekt>

<sekt inhalt="Multiproc.">
: ? @ . ;

: 2@ ( adr --> a b )
  DUP 1+ @ SWAP @ ;
: 2! ( a b adr --> )
  SWAP OVER ! 1+ ! ;
: 2? 2@ B. ;

XBIT VARIABLE RAMP3 ( RAMP3 TIB RAMP1
: RAMBUF ( /name/  n --> )
  MINUS RAMP3 +! RAMP3 @ CONSTANT ; ( oo INDVAR muss da her )

( - "Platinen befestigen und entfernen" )
20 RAMBUF TLISTE
TLISTE VARIABLE TLISTENZEIGER
: TLISTY 
  TLISTE BEGIN TLISTENZEIGER @ OVER > WHILE 
    DUP @ CR DUP M. 3 M- 2@ SWAP TYPE 
    1+ REPEAT DROP ;

0 VARIABLE REMOPFA
0 VARIABLE STATMERK
0 VARIABLE EXXIUHR
: EXXI
  ( UHRL @ >R
  STAT @ STATMERK ! 0 STAT ! ( eigentlich >R )
  TLISTE
  BEGIN DUP TLISTENZEIGER @ LT WHILE
    DUP >R @ EXECUTE R> 1+ REPEAT DROP
  STATMERK @ STAT ! 
  ( UHRL @ R> M- EXXIUHR ! 
  ;

( EXXI in KEY einbauen
04 ' EXXI MLIT ' KEY ! ( KEY war vorher : KEY BEGIN NOOP ... REPEAT ;

: ENTFERNE 
  20 WORD FIND LCFA DROP 1+
  ( DUP 0= IF 3 ERROR END_IF )
  0 REMOPFA !
  TLISTE BEGIN TLISTENZEIGER @ OVER > WHILE
    2DUP @ = IF
      1 REMOPFA !
      -1 TLISTENZEIGER +!
      END_IF
    REMOPFA @ IF
      DUP 1+ @ OVER !
      END_IF
    1+ REPEAT DROP
  REMOPFA !
  ;
  
: BEFESTIGE ENTFERNE
  REMOPFA @ TLISTENZEIGER @ !
  1 TLISTENZEIGER +! 
  ;


( jetzt los mit LINKS-RECHTS-OBEN-UNTEN
2804 CONSTANT LINKS-ABGESCHICKT
2804 CONSTANT RECHTS-ABGESCHICKT
2805 CONSTANT LINKS-ANGEKOMMEN
2805 CONSTANT RECHTS-ANGEKOMMEN
2806 CONSTANT OBEN-ABGESCHICKT
2806 CONSTANT UNTEN-ABGESCHICKT
2807 CONSTANT OBEN-ANGEKOMMEN
2807 CONSTANT UNTEN-ANGEKOMMEN
2000 CONSTANT RECHTS-BYTES
2400 CONSTANT UNTEN-BYTES
2000 CONSTANT LINKS-BYTES
2400 CONSTANT OBEN-BYTES
-1 VARIABLE IAM1X
-1 VARIABLE IAM1Y	
-1 VARIABLE IAM2X
-1 VARIABLE IAM2Y
0 VARIABLE LINKS-MERK
0 VARIABLE OBEN-MERK
0 VARIABLE RECHTS-MERK
0 VARIABLE UNTEN-MERK

: R-ABSCHICKEN ( x y Z adr n op --> )
  BEGIN RECHTS-ANGEKOMMEN @ RECHTS-MERK @ M- WHILE ." r_wart " REPEAT
  RECHTS-BYTES ! ( x y Z adr n
  DUP IF SWAP OVER RECHTS-BYTES 5 M+ SWAP MOVE ( x y Z n
    ELSE SWAP RECHTS-BYTES 5 M+ ! END_IF
  DUP RECHTS-BYTES 4 M+ !
    NEBENRECHNUNG ROT ROT
    RECHTS-BYTES 6 M+ M+ ERGEBNIS !
    400 SPEICHERENDE +!
    OBJ_STRUCT_COPY
    -400 SPEICHERENDE +!
    SWAP HAUPTRECHNUNG
  RECHTS-BYTES 3 M+ !
  2DUP
  RECHTS-BYTES 2 M+ !
  RECHTS-BYTES 1 M+ !
  RECHTS-ANGEKOMMEN @ NOT 1 AND RECHTS-MERK !
  RECHTS-ANGEKOMMEN @ NOT RECHTS-ABGESCHICKT !
  ." :r " B. ." r: "
  ;
: U-ABSCHICKEN ( x y Z adr n op --> )
  BEGIN UNTEN-ANGEKOMMEN @ UNTEN-MERK @ M- WHILE ." u_wart " REPEAT
  UNTEN-BYTES !
  DUP IF SWAP OVER UNTEN-BYTES 5 M+ SWAP MOVE ( j k Z n
    ELSE SWAP UNTEN-BYTES 5 M+ ! END_IF
  DUP UNTEN-BYTES 4 M+ !
    NEBENRECHNUNG ROT ROT
    UNTEN-BYTES 6 M+ M+ ERGEBNIS !
    800 SPEICHERENDE +!
    OBJ_STRUCT_COPY
    -800 SPEICHERENDE +!
    SWAP HAUPTRECHNUNG
  UNTEN-BYTES 3 M+ !
  2DUP
  UNTEN-BYTES 2 M+ !
  UNTEN-BYTES 1 M+ !
  UNTEN-ANGEKOMMEN @ NOT 1 AND UNTEN-MERK !
  UNTEN-ANGEKOMMEN @ NOT UNTEN-ABGESCHICKT !
  ." :u " B. ." u: " 
  ;
: ABSCHICKEN ( j k Z adr n op --> )
  6 LOCAL
  L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L1 @ L2 @ L3 @ L4 @ L5 @ L0 @ L1 @  ( j k Z adr n op j k )
  OVER DUP . IF 2DROP U-ABSCHICKEN
    L5 @ 3 = IF L2 @ L3 @ L4 @ ( Z adr n )
      DUP IF INTERPRET ELSE DROP
        DUP IF EXECUTE ELSE DROP END_IF END_IF
      END_IF
    ELSE DUP DUP . IF 2DROP R-ABSCHICKEN
      L5 @ 2 = IF L2 @ L3 @ L4 @ ( Z adr n )
        DUP IF INTERPRET ELSE DROP
          DUP IF EXECUTE ELSE DROP END_IF END_IF
        END_IF
      ELSE 2DROP DROP >R >R >R 2DROP R> R> R>
        DUP IF INTERPRET ELSE DROP DUP IF EXECUTE ELSE DROP END_IF END_IF
        END_IF END_IF
  END_LOCAL
  ;

( 5 6 1 " 77 . " 1 ABSCHICKEN

( 1 2 0 0 0 1 R-ABSCHICKEN
( RECHTS-BYTES 8 DUMP RECHTS-ABGESCHICKT ? RECHTS-ANGEKOMMEN ?
( RECHTS-ANGEKOMMEN @ RECHTS-ABGESCHICKT !
( 5 6 1 " 77 . " 1 U-ABSCHICKEN
( UNTEN-BYTES 8 DUMP UNTEN-ABGESCHICKT ? UNTEN-ANGEKOMMEN ?
( UNTEN-ANGEKOMMEN @ UNTEN-ABGESCHICKT !

: JK-PROC ( j k --> )
  CR ." :K " 2DUP B. ." K: "
  OVER IAM2X @ LT OVER IAM2Y @ LT AND IF -1 IAM1X ! -1 IAM1Y ! -1 IAM2X ! -1 IAM2Y ! END_IF
  OVER IAM1X @ = NOT IAM2X @ -1 = AND IF 
    IAM1X @ -1 = IF OVER IAM1X ! ELSE OVER IAM2X ! END_IF
    CR IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
    OVER 1+ OVER 0 0 0 0 U-ABSCHICKEN
    END_IF
  DUP IAM1Y @ = NOT IAM2Y @ -1 = AND IF 
    IAM1Y @ -1 = IF DUP IAM1Y ! ELSE DUP IAM2Y ! END_IF
    CR IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
    OVER OVER 1+ 0 0 0 0 R-ABSCHICKEN
    END_IF
  2DROP ;

( empfangene Bytes jetzt auswerten
( ENTFERNE L-AUSLES
( ENTFERNE O-AUSLES

: L-AUSLES
  LINKS-MERK @ LINKS-ABGESCHICKT @ = NOT IF
    LINKS-BYTES @ 0= IF
      LINKS-BYTES 1+ DUP @ SWAP 1+ @
      LINKS-ABGESCHICKT @ LINKS-MERK !
      LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
      JK-PROC
      END_IF
    LINKS-BYTES @ 1 = LINKS-BYTES @ 2 = OR IF
      LINKS-BYTES 2 M+ @ 1- IF ( bei y>0 weiterschicken )
        LINKS-BYTES 1+ @
        LINKS-BYTES 2 M+ @ 1-
        CR ." :l " 2DUP B. ." l: "
        LINKS-BYTES 3 M+ @
        LINKS-BYTES 5 M+
        LINKS-BYTES 4 M+ @ 0= IF @ END_IF
        LINKS-BYTES 4 M+ @ 1
        IAM2Y @ 1 = IF
          LINKS-ABGESCHICKT @ LINKS-MERK !
          LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
          R-ABSCHICKEN
          ELSE
            R-ABSCHICKEN
            LINKS-BYTES @ 2 = IF
              LINKS-BYTES 3 M+ @
              LINKS-BYTES 5 M+
              LINKS-BYTES 4 M+ @
              CR ." :nn " 2DUP B. 2DUP TYPE ." nn: " CR
              DUP IF INTERPRET ELSE DROP @
                DUP IF EXECUTE ELSE DROP END_IF END_IF
              END_IF
            LINKS-ABGESCHICKT @ LINKS-MERK !
            LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
            END_IF
        ELSE ( endlich angekommen )
          LINKS-BYTES 3 M+ @
          LINKS-BYTES 5 M+
          LINKS-BYTES 4 M+ @
          CR ." :n " 2DUP B. 2DUP TYPE ." n: "
          DUP IF INTERPRET ELSE DROP @
            DUP IF EXECUTE ELSE DROP END_IF END_IF
          LINKS-ABGESCHICKT @ LINKS-MERK !
          LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
          END_IF
      END_IF
    END_IF
  ;

: O-AUSLES
  OBEN-MERK @ OBEN-ABGESCHICKT @ = NOT IF
    OBEN-BYTES @ 0= IF
      OBEN-BYTES 1+ DUP @ SWAP 1+ @
      OBEN-ABGESCHICKT @ OBEN-MERK !
      OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
      JK-PROC
      END_IF
    OBEN-BYTES @ 1 = OBEN-BYTES @ 3 = OR IF
      OBEN-BYTES 1+ @ 1- IF ( bei y>0 weiterschicken )
        OBEN-BYTES 1+ @ 1-
        OBEN-BYTES 2 M+ @
        CR ." :o " 2DUP B. ." o: "
        OBEN-BYTES 3 M+ @
        OBEN-BYTES 5 M+
        OBEN-BYTES 4 M+ @ 0= IF @ END_IF
        OBEN-BYTES 4 M+ @ 1 
        IAM2X @ 1 = IF
          OBEN-ABGESCHICKT @ OBEN-MERK !
          OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
          U-ABSCHICKEN
          ELSE
            U-ABSCHICKEN
            OBEN-BYTES @ 3 = IF
              OBEN-BYTES 3 M+ @
              OBEN-BYTES 5 M+
              OBEN-BYTES 4 M+ @
              CR ." :NN " 2DUP B. 2DUP TYPE ." NN: "
              DUP IF INTERPRET ELSE DROP @ 
                DUP IF EXECUTE ELSE DROP END_IF END_IF
              END_IF
            OBEN-ABGESCHICKT @ OBEN-MERK !
            OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
            END_IF
        ELSE ( endlich in x angekommen, jetzt dasselbe noch y )
          OBEN-BYTES 2 M+ @ IF ( bei y>0 nach rechts weiterschicken )
            OBEN-BYTES 1+ @ 1-
            OBEN-BYTES 2 M+ @
            CR ." :O " 2DUP B. ." O: "
            OBEN-BYTES 3 M+ @ OBJ_STRUCT_COPY
            OBEN-BYTES 5 M+
            OBEN-BYTES 4 M+ @ 0= IF @ END_IF
            OBEN-BYTES 4 M+ @ 1 
            R-ABSCHICKEN
            OBEN-ABGESCHICKT @ OBEN-MERK !
            OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
            ELSE ( schon in x y angekommen )
              OBEN-BYTES 3 M+ @
              OBEN-BYTES 5 M+
              OBEN-BYTES 4 M+ @
              CR ." :N " 2DUP B. 2DUP TYPE ." N: "
              DUP IF INTERPRET ELSE DROP @ 
                DUP IF EXECUTE ELSE DROP END_IF END_IF
              OBEN-ABGESCHICKT @ OBEN-MERK !
              OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
              END_IF
          END_IF
      END_IF
    END_IF
  ;

( vor BEFESTIGE die verwendeten Eingänge rücksetzen
LINKS-ABGESCHICKT @ LINKS-MERK !
LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
OBEN-ABGESCHICKT @ OBEN-MERK !
OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
RECHTS-ANGEKOMMEN @ RECHTS-MERK !
UNTEN-ANGEKOMMEN @ UNTEN-MERK !

BEFESTIGE L-AUSLES
BEFESTIGE O-AUSLES

( HEX 0 0 JK-PROC 
( IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
( 9 9 77 "  ." 1 ABSCHICKEN
( 9 9 77 ' M. 0 1 ABSCHICKEN
( 9 9 77 0 0 1 ABSCHICKEN ( anschliessend .
( 9 9 [ [ 1 2 3 ] [ 4 5 6 ] ] ' . 0 1 ABSCHICKEN
</sekt>

<sekt inhalt="neues Invertieren">
1A00 ZAHLENSPEICHER ! INIT

0 VARIABLE N
0 VARIABLE NN
0 VARIABLE NI
0 VARIABLE NJ
0 VARIABLE NK
0 VARIABLE JLOC
0 VARIABLE KLOC
0 VARIABLE GXMERK

: M/ ( b d --> r q ) M/MOD SWAP DROP ;

: JLOC! JLOC ! ;
: KLOC! KLOC ! ;
: YCOL ( A k --> Y )
  3 LOCAL
  OVER SIZE L1 ! L2 ! L0 ! ( L0=A L1=jsize L2=k )
  0 L1 @ BEGIN 1- DUP L1 ! ( 0 jsize-1 )
    L0 @ OVER L L2 @ L ( 0 jsize-1 a_jk )
    H ( Y )
    L1 @ DUP 0= UNTIL ( Y jsize-1 )
  DROP ( Y )
  END_LOCAL
  ;

[ [ 1 2 ] [ 3 4 ] ] 1 YCOL . ( [ 2 4 ] )

: ZLOS ( A gx x Y --> A' gx' )
  ." ZLOS " 2OVER B. 2DUP B.
  2OVER DROP JLOC @ L OBJ_STRUCT_COPY DUP . ( A gx x Y Z )
  NJ @ 1- 0 ROT  ( A gx x Y NJ@-1 0 Z )
  IAM1X @ IAM1Y @ = IF OBJ_STRUCT_COPY KLOC @ G GXMERK @ - H END_IF OVER . DUP .
  ' [A*x-Y*Z]/gx 0 3 ABSCHICKEN
  ;

: XYLOS ( A gx x --> A' gx' )
  ." XYLOS "
  0 NK @ 1- ROT ' A+0 0 2 ABSCHICKEN ( A gx x )
  KLOC @ 2OVER DROP SWAP YCOL DUP . ( A gx x Y )
  0 NK @ 1- ROT ( A gx x 0 NK@-1 Y )
  IAM1X @ IAM1Y @ = IF OBJ_STRUCT_COPY JLOC @ G GXMERK @ + H ' ZLOS ELSE ' OBJ_STRUCT_COPY END_IF
  OVER . ( A gx x 0 NK@ Y 0 )
  0 2 ABSCHICKEN ( A' gx' )
  ;

( N, NJ, NK werden vorerst beim Matrix Aufteilen gesetzt
: GINV ( A gx n --> A' gx' )
  ." GINV "
  NN ! DUP GXMERK ! ( A gx )
  N @ NN @ M- NI !
  0 NK @ 1- NI @ N @ NJ @ M/ M/ ' JLOC! 0 2 ABSCHICKEN
  NJ @ 1- 0 NI @ N @ NK @ M/ M/ ' KLOC! 0 3 ABSCHICKEN
  OVER JLOC @ L KLOC @ L DUP . ( A gx x )
  NJ @ 1- 0 ROT ' XYLOS 0 3 ABSCHICKEN
  NN @ 1- IF 1 1 NN @ 1- " GINV " 1 ABSCHICKEN END_IF
  ;


</sekt>

<sekt inhalt="in den Zustand für Step_12 bringen und wieder RAM generieren">
( allerdings beim Compilieren von großen ganzen Zahlen im Moment noch 1234 ERROR

( an der Stelle Programm-VHDL-Quelltext für Step_12 ausgeben )
HEX INIT 
HERE 0 0 DUMPZ           ( generiert progRAM für P20_FFP.vhd Step_12
BZEIG @ BANF @ -1 DUMPZ  ( generiert byteRAM für P20_FFP.vhd Step_12
3000 2C00 0 DUMPZ        ( generiert stapR   für P20_FFP.vhd Step_12
</sekt>

<sekt inhalt="noch ein wenig DEMO">
111111111111111 DUP * .

( jetzt eine Matrix invertieren )

DECIMAL

[ [ 1 1 ^ 1 2 ^ 1 3 ^ 1 4 ^ ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ ]
  ] 
DUP .
4 INVERTIEREN ( mat dim --> invmat nenner )
OVER .
DUP .
( Ergebnis sollte sein: OVER .      )
(      [ [ 1152 -864 384 -72 ]      )
(        [ -1248 1368 -672 132 ]    )
(        [ 432 -576 336 -72 ]       )
(        [ -48 72 -48 12 ] ] ok     )
( und gemeinsamer Nenner: DUP . 288 )

HEX
</sekt>

</NACH_DEN_AXIOMEN>
</INIT>
