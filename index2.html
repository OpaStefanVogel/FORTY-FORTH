<p style="white-space: pre-wrap;">Benennung der Stapeleinträge

Für die obersten vier Stapeleinträge verwende ich extra Variablenbezeichnungen A, B, C, D, sowie eine Zählvariable T mit folgender Zuordnung

A := R(SP-1),
B := R(SP-2),
C := R(SP-3),
D := R(SP-4).

Genauso werden sie vor jeder Rechenoperation aus R gelesen. Nach Ausführung der Rechenoperation werden allerdings nur die T obersten in R zurückgespeichert. Beispielsweise entsteht bei der Addition ein einzelner neuer Stapeleintrag A:=A+B, dabei wird der Stapelzeiger SP um 1 vermindert und dann A an die neue Position R(SP-1) zurückgespeichert, also T:=1. Weil SP um 1 vermindert wurde, kann man B, C, D nicht automatisch wieder in R(SP-2), R(SP-3), R(SP-4) zurückspeichern, von woher sie ja gelesen wurden.

Addition:
A := A + B;
SP:= SP - 1;
T := 1;
R(SP-1) := D;
R(SP-2) bleibt unverändert B
R(SP-3) bleibt unverändert A
R(SP-4) bleibt unverändert

Variable T und das Zurückspeichern sind jetzt zusätzlich hinzugekommen. Der Vorteil soll sein, dass man bei der Programmierung der einzelnen Rechenoperationen nicht immer wieder R(SP-1), R(SP-2)... schreiben muss und letztere eventuell sogar wiederholt compiliert werden. Außerdem wird R(SP) als nächstes weiter in R(P(SP)) umgeschrieben, das kann dann außerhalb der Rechenoperationen erfolgen. Vorher nochmal ein Programmlauf, dabei werden die einzelnen Unterschiede im Quelltext mit ausgegeben. Am Ergebnis sollte sich aber nichts ändern.

Falls das Startterminal aus Step_1 noch offen ist:
<pre><code>
your-repo$ git pull Step_2
your-repo$ git checkout Step_2
your-repo$ git diff</code></pre>
und wenn die graphische Oberfläche von Vivado ebenfalls noch läuft, nur nochmal
<pre><code>Tcl Console: launch_simulation # = Run Behavioral Simulation
Tcl Console: run 1000 ns
</code></pre>
mit gleichem Ergebnis wie in Step_1</p>


type STAPELTYPE is array(0 to 31) of STD_LOGIC_VECTOR (15 downto 0);
signal stap1,stap2,stap3,stap0: STAPELTYPE;

function P(SP : integer) return integer is begin
  return CONV_INTEGER(CONV_UNSIGNED(SP,2));
  end;

variable A,B,C,D: STD_LOGIC_VECTOR (15 downto 0);
variable T: integer range 0 to 4;

R:=HOLE_VOM_STAPEL;
W:="0000";
  D:=R(P(SP-1));
  C:=R(P(SP-2));
  B:=R(P(SP-3));
  A:=R(P(SP-4));
  T:=0;
  if T>0 then R(P(SP-1)):=D;W(P(SP-1)):='1'; end if;
  if T>1 then R(P(SP-2)):=C;W(P(SP-2)):='1'; end if;
  if T>2 then R(P(SP-3)):=B;W(P(SP-3)):='1'; end if;
  if T>3 then R(P(SP-4)):=A;W(P(SP-4)):='1'; end if;
  ADRESSE_ZUM_STAPEL(0)<=CONV_STD_LOGIC_VECTOR(SP-1,16) and x"FFFD";
  ADRESSE_ZUM_STAPEL(1)<=CONV_STD_LOGIC_VECTOR(SP-2,16) and x"FFFD";
  ADRESSE_ZUM_STAPEL(2)<=CONV_STD_LOGIC_VECTOR(SP-3,16) or x"0002";
  ADRESSE_ZUM_STAPEL(3)<=CONV_STD_LOGIC_VECTOR(SP-4,16) or x"0002";
  STORE_ZUM_STAPEL(0)<=R(0);
  STORE_ZUM_STAPEL(1)<=R(1);
  STORE_ZUM_STAPEL(2)<=R(2);
  STORE_ZUM_STAPEL(3)<=R(3);
  WE_ZUM_STAPEL<=W;

--Stapel: 
process 
begin wait until (CLK_I'event and CLK_I='0');
  if WE_ZUM_STAPEL(1)='1' then 
    stap1(CONV_INTEGER(ADRESSE_ZUM_STAPEL(1)(11 downto 2)))<=STORE_ZUM_STAPEL(1); 
    HOLE_VOM_STAPEL(1)<=STORE_ZUM_STAPEL(1); 
	 else
      HOLE_VOM_STAPEL(1)<=stap1(CONV_INTEGER(ADRESSE_ZUM_STAPEL(1)(11 downto 2)));
    end if;
  end process;

</p>
