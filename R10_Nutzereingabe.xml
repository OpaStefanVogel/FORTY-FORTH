<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="R00.xsl" ?>
<los><step>10</step>Nutzereingabe

Variablen:
KEY_BYTE      = enthält das vom Nutzer eingegebene Byte
KEY_GESENDET  = wird invertiert, wenn dieses Byte abgeschickt wurde
Es fehlt eine Variable KEY_EMPFANGEN mit der gleichen Funktion wie EMIT_EMPFANGEN, ich hatte sie bisher nicht gebraucht.

Das Invertieren von EMIT_GESENDET ruft im darauffolgenden Takt das Unterprogramm ab Adresse 0016 auf (Interrupt). Dort wird EMIT_BYTE gelesen und im Eingabepuffer zwischengespeichert, anschließend das unterbrochene Programm fortgesetzt. Also muss generell beim Programmieren berücksichtigt werden, jederzeit an jeder Stelle kann eine solche Unterbrechung erfolgen.

Verwendete FORTH-Worte:
KEY  ( --> n ) wartet auf Nutzereingabe eines Zeichens und gibt es als n auf dem Stapel zurück.
*    ( a b --> a*b ) Multiplikation
.    ( n --> ) gibt n als Zeichenkette ins Terminal aus.
 
Beispiel: Rechne 56*89 

<term>git checkout Step_10
git diff Step_9 Step_10</term>
<tterm>close_sim -force -quiet
launch_simulation
run 3 ms</tterm>Der jetzige FORTH-Interpreter rechnet allerdings nur 16 Bit hexadezimal, das soll für den Moment auch reichen. Ergebnis:

<ffterm>FORTY-FORTH

ok
<u>56 89 * .</u> 2E06 ok
</ffterm>

Die Nutzereingabe <u>56 89 * .</u> ist farblich unterschiedlich dargestellt gegenüber der Programmausgabe. Die Nutzereingabe wurde mit Enter=0A abgeschlossen (nicht dargestellt). Sie erscheint ab 100000 ns in KEY_BYTE. Das Ergebnis wird beginnend ab 2378760 ns in EMIT_BYTE ausgegeben.  

<weiter />Pause
</los>
