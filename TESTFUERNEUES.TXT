( weiter hier Neues erstmal aufsammeln und nicht ständig neuen ProgRAM machen
( : . N. ; in DEMO.TXT war Unfug ( nur um Step_11 Simulation zu ermöglichen )
( deshalb muss ich das jetzt mühsam rückgängig machen:

( nach RESET zuerst FFINIT.TXT und FFINIT1SMUL1.TXT neu laden oder
7 ' NUMBER !
18 ' KEY_INT 6 + ! ( repariert KEY_INT
RP0 ' QUIT ! A00A ' QUIT 1 + !
QUIT
1B EMIT 5B EMIT 33 EMIT 39 EMIT 6D EMIT ( Farben aus
7 ' NUMBER !
8000 16 ! ( deaktiviert EXXI
4000 000E ! ( aktiviert ^F = QUIT
FORGET LDUMP
( --- ohne dem geht nix






( jetzt geht's aber weiter mit Neuem:


( also zu O.
( in H SLX->ERGEBNIS hinzu
( am Anfang von H DUP >R .... R> C000 AND dazu, aber das muss noch weiter
( ok Unterscheidung OBJ anhand l: l+4000 in L und H einfügen

: OBJ? ( a --> flag )
  ABS DUP 4000 < IF DROP 0 ELSE
    ZERLEG SWAP DROP 4000 < IF 0 ELSE -1 
      END_IF END_IF
  ;

: L ( a i -> b ) OVER OBJ? IF
    SWAP ZERLEG 3FFF AND ( i adr j
    ROT 2DUP ( adr j i j i )
    > IF SWAP DROP + @ ELSE 2DROP DROP 0 END_IF
    ELSE IF DROP 0 END_IF END_IF ;

: H ( a i b --> a' )
  DUP >R
  ROT ROT ( b a i
  OVER OBJ? 0= OVER 0= AND R> OBJ? 0= AND IF 2DROP ELSE
    OVER OBJ? 0= IF 
      DUP 1+ SPEICHERHOL ( b a i addrneu
      ROT OVER ! ( b i addrneu
(      OVER 1+ OVER 1 - ! ( b i addrneu ( aha, macht schon SPEICHERHOL
      4000 OVER 1 - +! ( das ist jetzt neu fuer OBJ?
      DUP >R + ! R> ( addrneu
      1 - 4000 +
      ELSE
        OVER ( b a i a
        ZERLEG 3FFF AND ( b a i addr j
        ROT ( b a addr j i
        2DUP > IF SWAP DROP ROT >R + ! R> ELSE
          DUP 1+ SPEICHERHOL ( b a addr j i addrneu
          SWAP >R DUP >R ( b a addr j addrneu      addrneu i
          SWAP MOVE DROP R> ( b addrneu            i 
(          R 1+ OVER 1 - ! ( b addrneu                i
          4000 OVER 1 - +! ( das ist jetzt neu fuer OBJ?
          SWAP OVER R> + ! ( addrneu
          1 - 4000 + ( a'
          END_IF
        ZERLEG 3FFF AND ( adr l
        BEGIN 2DUP + 1 - @ 0= OVER 1 > AND WHILE 1 - REPEAT ( adr lneu
        OVER @ OBJ? 0= OVER 1 = AND IF DROP @ ELSE
          SWAP 1 - SWAP ( addr-1 lneu
          4000 + OVER ! 4000 +
          END_IF  
        END_IF
    END_IF
  ;
  
: O. ( obj --> )
  DUP OBJ? IF
    ." [ "
    ZERLEG 3FFF AND OVER + SWAP ( eadr+1 aadr 
    BEGIN 2DUP > WHILE DUP @ RECURSE 1 + REPEAT 2DROP
     ." ] "
    ELSE N. END_IF
  ;

7 DUP O.
2 9 H DUP O.
3 11 H DUP O.
1 4 1 6 H H DUP O.
1 G 2 88 H H DUP O. 
1 G 2 0 H H DUP O.
0 G 2 1987 H H DUP O.
1 0 H DUP O.
3 0 H DUP O.
2 0 H DUP O.
2 2444 H DUP O.
0 N" 7777777" H DUP O.
2 0 H DUP O.


( 0 1 1 H ( da ist noch ein Defekt bei 0 0 7 H da macht ZERLEG Quatsch
0 ( jetzt geht ZERLEG richtig ok
0 0 0 1 H 1 2 H 2 5 H H DUP O.
1 0 0 3 H 1 4 H 2 8 H H DUP O.
2 0 0 9 H 1 2 H 2 1 H H CR DUP O.

0 1 4 H DUP O.
0 0 0 1 4 H H O.

0 
0 0 0 60 H 1 30 H 2 20 H H DUP O.
1 0 0 30 H 1 20 H 2 15 H H DUP O.
2 0 0 20 H 1 15 H 2 12 H H CR DUP O.

( ok das passt besser








( jetzt neue Matrixeingabe und neues INVERTIEREN

0 VARIABLE SPMERK
: [ ( ---> spmerk )
  SPMERK @ SP @ SPMERK !
  ;

: ] ( spmerk a b c d ... z --> matrix )
  0 BEGIN SP @ 1 - SPMERK @ - WHILE
    SP @ 2 - SPMERK @ - ROT H REPEAT
  SWAP SPMERK !
  ;

(   zuallerletzt nochmal NEBENRECHNUNG checken zuguterletzt dann auch noch B Y Z 
( NENNER als LOCAL und O. rein, uff, das ist ein Brocken. .. L0 war doch ( zuviel...

: INVERTIEREN ( matrix dim --> invmat nenner )
  ( L0=mat L1=N L2=i L3=j L4=k L5=Y L6=Z L7=alternenner )
  8 LOCAL
  L1 ! L0 ! 0 L5 ! 0 L6 !
  L0 @ 1 ( mat nenner )
  L1 @ L2 ! BEGIN -1 L2 +!
    L7 ! ( mat )
    L0 @ L2 @ L L2 @ L ( mat neuernenner )
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L L2 @ L L5 @ L3 @ ROT H L5 !
      OVER L2 @ L L3 @ L L6 @ L3 @ ROT H L6 !
      L3 @ 0= UNTIL
    L5 @ L2 @ L L7 @ N+ L5 @ L2 @ ROT H L5 !
    L6 @ L2 @ L L7 @ N- L6 @ L2 @ ROT H L6 !
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L ( mat nenner mat[L3] )
      L1 @ L4 ! BEGIN -1 L4 +!
        NEBENRECHNUNG ROT ROT SWAP ( mat erg mat[L3] nenner )
        OVER L4 @ L OVER N*
        L5 @ L3 @ L L6 @ L4 @ L N* N-
        L7 @ N/ ( mat erg mat[L3] nenner bijneu )
        2SWAP SWAP ( mat nenner bijneu mat[L3] erg )
        DROP ( HAUPTRECHNUNG ) SWAP ( A+0 ) ( mat nenner mat[L3] bijneu+0
        SWAP L4 @ ROT H ( mat nenner mat[L3]neu )
        L4 @ 0= UNTIL
      ROT L3 @ ROT H SWAP ( matneu nenner )
      L3 @ 0= UNTIL
    ( RECHENBLOCK )
    L2 @ 0= UNTIL
  END_LOCAL
  ; 
  




( so und jetzt anwenden

[ [ 3C 1E 14 ] ( dezimal 60 30 20
  [ 1E 14 0F ] ( dezimal 30 20 15
  [ 14 0F 0C ] ( dezimal 20 15 12
  ] 3
OVER O. DUP .
INVERTIEREN
OVER O. DUP .
( herauskommen muss dabei
(             [ [ F -3C 32 ] [ -3C 140 -12C ] [ 32 -12C 12C ] ] 0064
( dezimal        15 -60 ...                                      100
( stimmt, also Schluss für heut
