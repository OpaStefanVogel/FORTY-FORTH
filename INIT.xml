<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="INIT.xsl" ?>
<!DOCTYPE INIT SYSTEM "INIT.DTD">
<INIT>
<AXIOME>
<sekt inhalt="Axiome (sie enthalten Vorwärtsreferenzen und sind deshalb separat zusammengefasst)">
<sekt inhalt="vorab der Ablauf, was tun, wenn diese Axiome geändert werden müssen">
( wenn die Axiome so bleiben wie sie sind, ganz normal 1x hintereinanderweg compilieren )
( wenn die Axiome verändert werden sollen, dann )
  ( zuerst RESET und 1x die ursprünglichen Axiome laden ) 
  ( anschließend die neuen Axiome compilieren, so: )
    ( HERE 100 + DPMERK ! E800 BANF ! )
    ( 2x neue Axiome compilieren <REF1/> )
    ( 058 DPMERK ! E000 BANF ! )
    ( 2x neue Axiome compilieren <REF1/> nochmal ) 
    ( danach alles, was nach den AXIOMEN folgt, 1x compilieren )
  ( bei verzwickten Veränderungen kann es vorkommen, 
  ( dass noch weitere Zwischenschritte eingefügt werden müssen. )
</sekt>

<sekt inhalt="Anfangszustand so herstellen wie zum Recompilieren benötigt">
( zuerst alles Notwendige wieder auf Ausgangszustand schalten )
2 2 * DUP * BASE ! ( HEX )
7 ' NUMBER ' EXPECT 1 + @ OVER 1 + ! ! ( original NUMBER )
B501 ' LIT, ! 3FFF ' LIT, 1 + !        ( original LIT, )
4000 000E !        ( aktiviert ^F = START )
' DUMPZ 4 - LFA !  ( LFA zurueck auf Anfangsvokabular )

DPMERK @ DP ! BANF @ BZEIG ! ( DP und BZEIG zurücksetzen )
</sekt>

<sekt inhalt="so, mit irgendwas muss das Compilieren losgehen">
IMMEDIATE: ( 29 WORD 2DROP ;
IMMEDIATE: { 0 STAT ! ; ( war ursprünglich mal [ )  
: } 1 STAT ! ;
IMMEDIATE: COMPILE 20 WORD FIND LCFA DROP COMPILE, ;
COMPILE: (LIT,) R> DUP 1+ >R @ ;
: LIT, ( a --> ) DUP 3FFF > OVER C000 LT OR IF COMPILE (LIT,) END_IF , ;
COMPILE: (CONSTANT:) R> @ STAT @ IF LIT, END_IF ;
</sekt>

<sekt inhalt="Konstanten">
: CONSTANT ( /name/  c --> ) CREATE COMPILE (CONSTANT:) , SMUDGE ;

D001 CONSTANT SP
D002 CONSTANT RP
D003 CONSTANT PC

( für das Folgende freigehaltene Adressen: 0040-0057 )
40 CONSTANT XBIT
41 CONSTANT SMUDGEBIT
42 CONSTANT RP0 3000 RP0 !
43 CONSTANT IRAMADR
44 CONSTANT JRAMADR
45 CONSTANT XOFF
46 CONSTANT CRBZEIG BZEIG @ CRBZEIG !
47 CONSTANT CRDP DP @ 8 - CRDP !

48 CONSTANT BASE
49 CONSTANT TIB
4A CONSTANT IN1
4B CONSTANT IN2
4C CONSTANT IN3
4D CONSTANT IN4
4E CONSTANT ERRORNR 0 ERRORNR !
4F CONSTANT DP
50 CONSTANT STAT 0 STAT !
51 CONSTANT LFA
52 CONSTANT BANF
53 CONSTANT BZEIG
54 CONSTANT DPMERK
55 CONSTANT CSP
56 CONSTANT LOCALADDR

VERSION 1+ CONSTANT VERSION VERSION .
</sekt>

<sekt inhalt="Maschinencode">
A003 CONSTANT RETURN
COMPILE: (MCODE:) R> STAT @ IF @ , ELSE EXECUTE END_IF ;
: MCODE CREATE COMPILE (MCODE:) , RETURN , SMUDGE ;

A000 MCODE MINUS
A001 MCODE U+
A002 MCODE U*
A00D MCODE 0=
A00F MCODE 0LT
A005 MCODE EMITCODE
A00B MCODE NOT
A008 MCODE AND
A00E MCODE OR
A00C MCODE KEYCODE
A007 MCODE +
A009 MCODE !
A00A MCODE @
B412 MCODE SWAP
B502 MCODE OVER
B501 MCODE DUP
B434 MCODE ROT
B300 MCODE DROP
B43C MCODE 2SWAP
B60C MCODE 2OVER
B603 MCODE 2DUP
B200 MCODE 2DROP
8000 MCODE NOOP
</sekt>

<sekt inhalt="ein Abschnitt für die Zeichenketten">
: B, ( b --> ) BZEIG @ ! 1 BZEIG +! ;
: Z, ( badr n --> ) BZEIG @ LIT, DUP ,
  BEGIN SWAP DUP @ B, 1+ SWAP 1 - DUP 0= UNTIL
  2DROP 20 B, ; 
COMPILE: (WORD:) WORD STAT @ IF Z, R> COMPILE, END_IF ;
: WORD: CREATE 1 STAT ! , COMPILE (WORD:) -1 CSP +! ;
22 WORD: " ;
22 WORD: ." TYPE ;
</sekt>

<sekt inhalt="weiter mit Programmstrukturen">
: HERE DP @ ;
: JRBIT 8 ;
: JR0BIT 9 ;
: XSETBT 1000 * SWAP 0FFF AND OR ;
: ALLOT DP +! ;
: BRANCH, HERE 1+ - JRBIT XSETBT , ;
: 0BRANCH, HERE 1+ - JR0BIT XSETBT , ;
IMMEDIATE: BEGIN HERE ;
IMMEDIATE: AGAIN BRANCH, ;
IMMEDIATE: UNTIL 0BRANCH, ;
IMMEDIATE: IF JR0BIT 1 ALLOT HERE ;
IMMEDIATE: END_IF HERE OVER - ROT XSETBT SWAP 1 - ! ;
IMMEDIATE: ELSE 1 ALLOT COMPILE END_IF JRBIT HERE ;
IMMEDIATE: WHILE COMPILE IF ;
IMMEDIATE: REPEAT ROT COMPILE AGAIN COMPILE END_IF ;
</sekt>

<sekt inhalt="etliche kleinere Funktionen">
: C@ @ ;
: C! ! ;
: 1+ ( a --> a+1 ) 1 + ;
: - MINUS + ;
: = - 0= ;
: LT ( a b --> r ) 8000 + SWAP NOT 8000 + 0 U+ DROP 0= NOT ;
: > ( a b --> r ) SWAP LT ;
: * ( a b --> a*b ) 0 ROT ROT U* SWAP DROP ;
: BYE BEGIN ." BYE " AGAIN ;
: +! ( a adr --> adr+1 ) SWAP OVER @ + SWAP ! ;
: R> RP @ 1+ @ RP @ 1+ RP 2DUP @ @ SWAP ! ! ;
: >R RP @ DUP -1 + RP 2DUP @ @ SWAP DUP -1 + RP ! ! ! ! ; 
: R RP @ 1+ @ ; ( bei R> >R nicht unterhalb RP speichern wegen INTXY )
: , DP @ ! 1 DP +! ;
: EXECUTE PC ! ;
: KEY 12 EXECUTE ;
: EMIT ' EMITCODE EXECUTE ;
: SHL16 ( a --> t a' )
  0 SWAP 10 U* SWAP ; ( t a' = SHL a )
: DIG ( n --> c )
  DUP 0A LT IF ELSE 7 + END_IF 30 + ;
: TYPE
  BEGIN DUP WHILE
    SWAP DUP C@ EMIT 1+
    SWAP 1 - REPEAT
  2DROP ;
: HG. SHL16 DIG EMIT SHL16 DIG EMIT SHL16 DIG EMIT
  SHL16 DIG EMIT DROP ;
: H. HG. 20 EMIT ;
: . H. ;
: ? @ . ;
: CR 
  CRDP @ DP @ - STAT @ 0= NOT OR XBIT @ 0= NOT AND IF 
    3C EMIT ." fl>" CRDP @ . CRBZEIG @ . 3C EMIT ." /fl>"
    3C EMIT ." fr>" DP @ . BZEIG @ . 3C EMIT ." /fr>"
    DP @ CRDP ! BZEIG @ CRBZEIG ! 
    END_IF
  0A EMIT ;
: FEHLERTEXT ( n --> n ) ;
: DISABLE 
  CR ." weiter nach Taste ESCAPE "
  BEGIN 20 EMIT 8 EMIT KEY 1B = UNTIL ; 
: ERROR
  DUP ERRORNR !
  0 STAT !
  CR IN1 @ IN3 @ IN1 @ - 1 - TYPE ." ???"
  " FEHLERTEXT" INTERPRET
  CR ." ERROR - Fehler Nummer " . 
  DISABLE QUIT ;
: CSP! SP @ CSP ! ;
: CSP? SP @ CSP @ - IF 9 ERROR END_IF ;
</sekt>

<sekt inhalt="lokale Variablen">
: LOCAL ( n --> )
  R> SWAP 
  DUP MINUS RP @ + RP !
  RP @ LOCALADDR @
  >R LOCALADDR !
  >R ( LOCALDIST )
  >R ;
: END_LOCAL
  R>
  R> ( LOCALDIST )
  R> LOCALADDR ! 
  RP @ + RP !
  >R ;  
: L0 LOCALADDR @ ;
: L1 LOCALADDR @ 1+ ;
: L2 LOCALADDR @ 2 + ;
: L3 LOCALADDR @ 3 + ;
: L4 LOCALADDR @ 4 + ;
: L5 LOCALADDR @ 5 + ;
: L6 LOCALADDR @ 6 + ;
: L7 LOCALADDR @ 7 + ;
</sekt>

<sekt inhalt="alles zu KEY">
IMMEDIATE: ' ( /name/ --> --> pfa ) 
  20 WORD FIND LCFA DROP 1+ STAT @ IF LIT, END_IF ; 

: INCR4 ( adr --> )
  DUP @ 1 +
  DUP 3FF AND 000 = IF 400 - END_IF 
  SWAP !
  ;

: KEY_INT ( --> )
  D000 @ 
  DUP 08 LT IF 
    18 + @ DUP IF DUP EXECUTE END_IF
    DROP
    ELSE
      IRAMADR @ ! 
      IRAMADR INCR4
      IRAMADR @ JRAMADR @ - 3FF AND 
      100 > IF XOFF @ 0= IF -1 XOFF ! 13 EMIT END_IF END_IF 
      END_IF
  0 D000 !
  ;

: KEYCODE2 ( --> c f )
  JRAMADR @ IRAMADR @ = IF 0 0 
    ELSE JRAMADR @ @ -1
    JRAMADR INCR4
    IRAMADR @ JRAMADR @ - 3FF AND
    80 LT IF XOFF @ IF 0 XOFF ! 11 EMIT END_IF END_IF
    END_IF
  ;

' KEY_INT 4000 + 26 !
' KEYCODE2 4000 + 12 !
</sekt>

<sekt inhalt="es folgt der Interpreter">
( ESCAPE durch EXPECT durchlaufen lassen )
( und 7F in 08 umwandeln )
( und nach n Zeichen kein 0D mehr lesen )
: EXPECT ( /text/  adr n --> adr m )
  5 LOCAL
  L2 ! L1 ! L1 @ L4 !
  BEGIN
    KEY
    DUP 14 ( 20 ) ( =^T, ^R=18 ) = IF 
      DROP L1 @ C@ END_IF
    DUP 7F = IF DROP 08 END_IF
    DUP 08 = IF L4 @ L1 @ LT IF
      -1 L1 +!
      1 L2 +!
      8 EMIT 20 ( 32 ) EMIT 8 EMIT
      END_IF END_IF
(    DUP 20 ( 32 ] LT NOT OVER 08 = OR OVER 1B = OR L2 @ 0= NOT AND WHILE
      DUP 20 LT IF ( DROP ) ELSE
        -1 L2 +!
        L2 @ 0LT IF 6 ERROR END_IF
        DUP EMIT
        DUP L1 @ C! 1 L1 +!
        END_IF 
    DUP 20 LT OVER 08 = NOT AND SWAP 1B = NOT AND L2 @ 0= OR UNTIL
(      REPEAT
  20 ( 32 ) EMIT
  L4 @ L1 @ L4 @ -
  2DUP + 0 SWAP C!
  END_LOCAL
  ;


: DIGIT ( z --> d r ) ( r=-1 wenn gueltig )
  ( vorher r=0 wenn gueltig!!! )
  DUP 30 ( 30 48 ) LT NOT OVER 3A ( 3A 58 ) LT AND
  OVER 41 ( 41 65 ) LT NOT OR 
  DUP IF ( z -1 wenn gueltig )
    SWAP 30 ( 30 48 ) -
    DUP 0A LT NOT IF 7 - END_IF
    DUP BASE @ LT NOT IF DROP DROP 0 0 END_IF
    SWAP END_IF ;

: NUMBER ( badr n --> a r )
  7 LOCAL ( L3 L4 nicht verwendet )
  L1 ! L0 !
  0 L1 @ IF
    DUP L2 ! 1 L5 ! ( Vorzeichen )
    BEGIN ( M23 Vorzeichen gucken )
      -1 L6 ! 
      L0 @ L2 @ + C@
      2B ( 43 2B ) = IF L2 @ 1+ L2 ! 0 L6 ! ELSE
        L0 @ L2 @ + C@
        2D ( 45 2D ) = IF L2 @ 1+ L2 !
          0 L6 !
          L5 @ MINUS L5 ! END_IF
        END_IF
      L6 @ UNTIL
    L2 @ L1 @ LT IF
      BEGIN
        L0 @ L2 @ + C@
        DUP IF ( oo L1 auf Bytes )
          DIGIT NOT IF DROP L1 @ MINUS L1 ! ELSE
            SWAP BASE @ * +
            L2 @ 1+ L2 ! 
            END_IF
          ELSE DROP L2 @ L1 ! END_IF
        L2 @ L1 @ LT NOT UNTIL
      END_IF ( M19 )
    END_IF ( M19 )
  L5 @ 0LT IF MINUS END_IF
  L2 @ L1 @ - ( oo noch kein fadr )
  END_LOCAL
  ;

: WORD ( b --> adr n )
  >R
  IN3 @ IN2 !
  BEGIN 
    IN3 @ C@ R = IN3 @ IN4 @ LT AND WHILE
      1 IN3 +! REPEAT
  IN3 @ IN2 !
  BEGIN 
    IN3 @ C@ 3C = IF IN3 @ IN4 ! END_IF ( alles nach 3C ist Kommentar )
    IN3 @ C@ R = NOT IN3 @ IN4 @ LT AND WHILE
      1 IN3 +! REPEAT
  IN2 @ IN3 @ OVER -
  DUP IF 1 IN3 +! END_IF
  R> DROP
  ;

: Z= ( adr1 n1 adr2 n2 --> r )
  >R OVER R - IF R> DROP DROP DROP DROP 0 ELSE
    R> DROP SWAP 0 BEGIN 2DUP - WHILE >R >R
      OVER C@ OVER C@ - IF DROP DROP 0 0 END_IF
      DUP IF 1+ SWAP 1+ SWAP END_IF
      R> R> 1+ REPEAT 2DROP ( neu bei 16 BIT ohne DO LOOP )
    DROP IF -1 ELSE 0 END_IF
    END_IF ;
( : Z= DROP SWAP DROP SWAP @ SWAP @ = ;

: FIND ( adr n --> lfa r )
  >R >R 0 ( heisst noch nicht gefunden )
  LFA @ 
  SMUDGEBIT @ IF DUP @ + END_IF
  BEGIN
    DUP 1+ DUP @ ( lfa nfa adr )
    SWAP 1+ @ ( lfa adr n1 )
    ( 2DUP CR B. 2DUP TYPE
    ( BEGIN 2DUP + 1 - C@ 0= WHILE 1 - REPEAT ( ??? momentan nicht )
    R> R> 2DUP >R >R ( 0 lfa adr1 n1 adr2 n2 )
    Z= IF SWAP 0= SWAP END_IF ( heisst gefunden )
    OVER 0= OVER @ 0= NOT AND 
    OVER DUP @ + LFA @ = NOT AND WHILE ( wegen 2xladen )
      DUP @ + REPEAT
  R> DROP R>
  ROT 0= IF DROP DROP 0 0 END_IF
  ( OVER LFA @ SWAP LT IF ." *" OVER . LFA @ . END_IF ( vref wenn gebraucht )
  ;

: LCFA ( lfa r --> cfa r ) SWAP 3 + SWAP ;

: COMPILE, ( adr --> ) 4000 + , ;

: CREATE ( /name/  --> )
  CSP! ( Stapelbalance prüfen in ; )
  DP @ LFA @ OVER - , LFA !
  20 WORD Z,
  1 SMUDGEBIT ! ( HERE 2 - DUP @ MINUS SWAP ! ( UNSMUDGE )
  ;

: INTERPRET ( adr n --> ... )
  IN1 @ >R IN2 @ >R IN3 @ >R IN4 @ >R
  OVER + IN4 !
  DUP IN1 ! DUP IN2 ! IN3 !
  BEGIN
  ( ... qstack? Stapelpruefen )
  20 WORD
  DUP WHILE
    2DUP FIND 
    DUP IF ( gefunden )
      >R >R 2DROP R> R> LCFA DROP EXECUTE
      ELSE ( nicht gefunden )
        2DROP
        2DUP NUMBER IF ( keine Zahl )
          2DROP DROP
          3 ERROR
         ( DROP BNUMBER
         ( DUP IF DUP IN2 ! END_IF
         ( IF 3 ERROR END_IF
         ( STAT @ IF SWAP LIT, LIT, END_IF
          ELSE ( eine Zahl )
            ROT DROP SWAP DROP
            STAT @ IF LIT, END_IF ( oo LIT, fuer gr )
            END_IF
        END_IF
    REPEAT 2DROP
  R> IN4 ! R> IN3 ! R> IN2 ! R> IN1 !
  ;

: QUIT
  RP0 @ RP ! 
  XBIT @ IF 3C EMIT ." /ok>" ELSE ." ok" END_IF
  BEGIN ( im Prinzip nur BEGIN CR TIB @ 100 EXPECT INTERPRET AGAIN )
    CR 
    TIB @ 100 EXPECT
    OVER @ 3C = IF 2DROP ELSE ( xml am Zeilenanfang gleich überlesen )
      XBIT @ IF 
        3C EMIT ." ok>" 
        INTERPRET 
        3C EMIT ." /ok>" 
        ELSE
          1B EMIT 5B EMIT 33 EMIT 36 EMIT 6D EMIT
          INTERPRET 
          STAT @ 0= IF ." ok" END_IF 
          1B EMIT 5B EMIT 33 EMIT 39 EMIT 6D EMIT
          END_IF 
      END_IF
    AGAIN 
  ;


: START ." FORTY-FORTH" CR CR QUIT ;


: SMUDGE 0 SMUDGEBIT ! ( LFA @ 1+ DUP @ DUP 0LT IF MINUS END_IF SWAP ! ) ;

: (IMMEDIATE:) R> >R ;
:   (COMPILE:) R> COMPILE, ;
:          (:) R> STAT @ IF COMPILE, ELSE >R END_IF ;

: IMMEDIATE: CREATE 1 STAT ! COMPILE (IMMEDIATE:) ;
:   COMPILE: CREATE 1 STAT ! COMPILE (COMPILE:) ;
:          : CREATE 1 STAT ! COMPILE (:) ;

( das hier jetzt mit dem neuen CREATE: )
IMMEDIATE: ; 0 STAT ! CSP? A003 , SMUDGE { SMUDGE } ; 
( tatsaechlich { SMUDGE } wegen 2x laden!!! ) 
( Ende der Axiome. Hiermit enden die Axiome. )
</sekt>

0 DPMERK @ ! ( abkoppeln )
HERE . BZEIG ?

START
</sekt>
</AXIOME>

<FFINIT2>
<sekt inhalt="bis Adresse 0800H passt noch DUMPZ drauf (inzwischen nicht mehr)">
( erste Forth Erweiterungen )
( - DUMPZ )
( RAMB-Inhaltsausgabe erzeugen: )
: DUBIT HERE ;
: LG. ( n --> )
  DUBIT @ IF SHL16 DROP SHL16 DROP 
    ELSE SHL16 DIG EMIT SHL16 DIG EMIT END_IF 
  SHL16 DIG EMIT SHL16 DIG EMIT DROP ;
: NG. ( n --> )
  ." x" 22 EMIT LG. 22 EMIT ." ," ; 
: DUMPZ ( bis+1 von dubit --> )
  DUBIT ! XBIT @ >R 0 XBIT !
  " ' START " INTERPRET 4000 + 10 !
  CR 3C EMIT ." DUMPZ>"
  BEGIN
    CR ."   "
    0000 BEGIN 
      2DUP + 
      DUP IRAMADR = IF DROP JRAMADR END_IF
      @ NG. 1+ DUP 10 = 
      UNTIL DROP
    ."  -- " DUP HG. ." -" DUP 0F + . 
    10 +
    2DUP > NOT UNTIL 2DROP
  CR 3C EMIT ." /DUMPZ>"
  R> XBIT !
  ; 

HERE . BZEIG ?
</sekt>

<sekt inhalt="ProgRAM und ByteRAM für Step_9 und Step_10 erstellen">
HERE 0 0 DUMPZ          ( generiert ProgRAM für P20_FFP.vhd Step_10 )
BZEIG @ E000 -1 DUMPZ   ( generiert ByteRAM für P20_FFP.vhd Step_10 )
</sekt>

<sekt inhalt="Variablen">
2F00 CONSTANT RAMP1 RAMP1 1+ RAMP1 !
: VARIABLE RAMP1 @ DUP CONSTANT DUP 1+ RAMP1 ! ! ;
</sekt>

<sekt inhalt="noch paar hilfreiche Funktionen">
: MOVE ( adr1 adr2 n --> )
  BEGIN DUP WHILE >R OVER @ OVER ! SWAP 1+ SWAP 1+ R> 1 - REPEAT DROP 2DROP ;
: FILL ( adr n b --> )
  ROT ROT BEGIN DUP WHILE >R 2DUP ! 1 + R> 1 - REPEAT DROP 2DROP ;

: DUMP ( addr n --> )
  BEGIN SWAP ( CR DUP . ) DUP @ . 1 + SWAP 1 - DUP 0= UNTIL DROP ;

: MAX ( a b --> c )
  2DUP LT IF SWAP END_IF DROP ;
: MIN ( a b --> c )
  2DUP > IF SWAP END_IF DROP ;
: ABS DUP 0LT IF MINUS END_IF ;
</sekt>

<sekt inhalt="Multiplikation">
A017 MCODE MULT_I
A018 MCODE MULT_II
: SUPERMULT ( a u adrc adrb n --> a u' adrc' adrb' )
  >R
  BEGIN MULT_I MULT_II UNTIL
  R> DROP ; ( /;> )





1401 CONSTANT A
1601 CONSTANT B
1801 CONSTANT C
A 1FF 1111 FILL
B 1FF 1111 FILL
C 3FF 0000 FILL

1111 0 C B 4 SUPERMULT . . . .
C 8 DUMP





: SMUL ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3)
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ + 1+
  L6 @ OVER 0 FILL
  L6 @ 
  DUP L2 @ L1 @ BEGIN
    0 2OVER @ ROT ROT L5 @ L4 @ ( ... a u  adrc  adrb n )
    SUPERMULT                   ( ... a u' adrc' adrb' )
    DROP ! DROP

(    vorher: )
(    L4 @ 0 
(    BEGIN OVER WHILE SWAP -1 + SWAP
(      0 SWAP 
(      L6 @ @ L5 @ @ L2 @ @ U* D+ 
(      L6 @ DUP 1 + L6 ! !
(      L5 @ 1 + L5 !
(      REPEAT
(    L6 @ ! DROP

    ROT 1 + ROT 1 + ROT -1 + ( 1 L2 +! 1 L6 +!
    DUP 0= UNTIL DROP 2DROP
  END_LOCAL
  ;

C 8 0 FILL
0 2 A 0 2 B C SMUL . . .
C 8 DUMP

C 201 0 FILL
0 100 A 0 100 B C SMUL . . .
C 8 DUMP

C 101 0 FILL
0 80 A 0 80 B C SMUL . . .
C 8 DUMP

( C 2001 0 FILL
( 0 1000 A 0 1000 B C SMUL . . .
( C 8 DUMP
</sekt>

<sekt inhalt="Addition"> 
: ADDIER ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 )
         ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L1 @ L4 @ MAX 1+ L6 @
  L0 @ L3 @ = IF
    0 L1 @ L4 @ MAX 0 BEGIN ROT
                 ( hier ist mal ! @ gewesen!!! )
      OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
      SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! ELSE 0 END_IF
      U+ L6 @ DUP 1+ L6 ! !
      ROT ROT 1 + 2DUP - 0= UNTIL 2DROP L6 @ !
    ELSE SWAP 1 - SWAP
      1 L1 @ L4 @ MAX 0 BEGIN ROT
        OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
        SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! NOT ELSE -1 END_IF
        U+ L6 @ DUP 1+ L6 ! !
        ROT ROT 1 + 2DUP - 0= UNTIL 2DROP ( DUP .
        0= IF DUP L6 !
          ROT NOT ROT ROT
          1 L1 @ L4 @ MAX 0 BEGIN ROT
            0 L6 @ @ NOT U+ 
            L6 @ DUP 1+ L6 ! !
            ROT ROT 1 + 2DUP - 0= UNTIL 2DROP DROP
          END_IF
      END_IF 
  END_LOCAL ;


C 8 0 FILL
0 2 A 0 2 B C ADDIER . . .
C 8 DUMP

C 8 0 FILL
0 5 A 0 7 B C ADDIER . . .
C 8 DUMP

C 8 0 FILL
0 7 A 0 3 B C ADDIER . . .
C 8 DUMP

A 8 FFFF FILL
C 8 0 FILL
0 2 A 0 2 B C ADDIER . . .
C 8 DUMP ( 1110 1111 0001 0000 )


A 8 2222 FILL
C 8 0 FILL
0 2 A -1 2 B C ADDIER . . .
C 8 DUMP

C 8 0 FILL
-1 2 A 0 2 B C ADDIER . . .
C 8 DUMP

C 8 0 FILL
0 2 B -1 2 A C ADDIER . . .
C 8 DUMP

C 8 0 FILL
-1 2 B 0 2 A C ADDIER . . .
C 8 DUMP
</sekt>

<sekt inhalt="Division">
A014 MCODE DI32 
: DIV32 ( a b d --> r q )
  10 BEGIN >R DI32 R> 1 - DUP 0= UNTIL 2DROP ;
: /MOD ( b d --> r q ) 0 ROT ROT DIV32 ;
: /MOD ( a b --> r q )
  OVER 0LT IF SWAP MINUS SWAP
    DUP 0LT IF MINUS /MOD SWAP MINUS SWAP
      ELSE /MOD MINUS SWAP MINUS SWAP END_IF
    ELSE DUP 0LT IF MINUS /MOD MINUS
      ELSE /MOD END_IF END_IF
  ;
: / ( b d --> q ) /MOD SWAP DROP ;
: MOD ( b d --> r ) /MOD DROP ;



: SDIV ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 s4 l4 r4 )
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
L1 @ L4 @ LT IF L0 @ L1 @ L2 @ 0 0 0 ELSE
  L1 @ 0 BEGIN
    L2 @ OVER + @ NOT OVER L6 @ + !
    1 + 2DUP - 0= UNTIL 2DROP
  L6 @ L1 @ + L4 @ - L2 !
  -1 L6 @ L1 @ + ! 1 L1 +!
  L1 @ L4 @ - 0 BEGIN
    L2 @ L4 @ + @ NOT
    L2 @ L4 @ + 1 - @ NOT
    L5 @ L4 @ + 1 - @      ( a b c )
    DIV32 
    SWAP DROP              ( q )
    DUP L2 @ L4 @ + 1+ !
    0 L2 @ L5 @ L4 @       ( c ü adrc adrb n )
    SUPERMULT
    2DROP SWAP DROP
    0 L2 @ L4 @ + @ U+ L2 @ L4 @ + !
BEGIN WHILE
 1 L4 @ 0 BEGIN ROT
   OVER L2 @ OVER + @
   SWAP L5 @ + @ NOT
   U+ SWAP >R OVER L2 @ + ! R>
   ROT ROT 1 + 2DUP - 0= UNTIL 2DROP
(   0 L2 @ L4 @ + @ U+ L2 @ L4 @ + !
(   DUP . 7 EMIT
 -1 L2 @ L4 @ + 1+ +!
REPEAT
    -1 L2 +!
    1 + 2DUP - 0= UNTIL 2DROP
  L4 @ 0 BEGIN
    L6 @ OVER + @ NOT OVER L6 @ + !
    1 + 2DUP - 0= UNTIL 2DROP
  L4 @ L6 @ 1 - !
  L1 @ L4 @ - L6 @ L4 @ + !
( CR ." ++" L6 @ L1 @ 1 + DUMP ." ++"
  L0 @ L4 @ L6 @
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ -
  L6 @ L4 @ + 1 +
 END_IF
  END_LOCAL
  ;

( 333333 4 N^ 10 N* VARIABLE NA
( 333333 DUP N* 10 N* VARIABLE NB
( NA @ 10 DUMP
( NA @ NB @ 2OPERANDEN->2SLX OVER . DUP . SDIV

654321 A !
234567 A 1+ !
000001 A 2 + !
432101 B !
A98765 B 1+ !

0 3 A 0 2 B C SMUL . . .
C 8 DUMP

0 4 C 0 2 B A SDIV . . . . . .
A 8 DUMP
</sekt>

<sekt inhalt="Zahlenspeicher">
0 VARIABLE OPERAND1
0 VARIABLE OPERAND2
1400 VARIABLE ERGEBNIS
1400 VARIABLE ZAHLENSPEICHER
2000 VARIABLE SPEICHERENDE
0 VARIABLE SCHIEB


: SLX->ERGEBNIS ( sz lz az --> z )
  OVER 0= IF 2DROP DROP 0 ELSE ( 0 bei 1/7 )
    2DUP + BEGIN 1 - DUP @ 0= NOT UNTIL 
    1 + OVER MAX ( sz lz az ez )
    ( DUP ERGEBNIS ! ( nicht wegen 0 1 OPERAND1 )
    2DUP = IF 2DROP 2DROP 0 ELSE
      OVER - ( sz lz az lneu )
      OVER @ C000 AND 0=
      OVER 1 = AND IF
        DROP @ ELSE ( warum war da -1 ERGEBNIS +! )
          OVER 1 - !
          1 - 4000 OR
          END_IF 
      SWAP DROP 
      SWAP IF MINUS END_IF
      END_IF
    END_IF
  ;
0 8 C SLX->ERGEBNIS .

: OPERAND->SLX ( op --> sx lx ax )
  DUP @ ( op x )
  DUP 0LT IF MINUS -1 ELSE 0 END_IF
  ROT ROT ( sx op xabs )
  DUP 4000 AND IF
    SWAP DROP
    3FFF AND
    DUP @ SWAP 1+
    ELSE
      OVER ! 1 SWAP 
      END_IF
  ;

77 OPERAND1 !
OPERAND1 OPERAND->SLX . . .
-77 OPERAND1 !
OPERAND1 OPERAND->SLX . . .
5800 OPERAND1 !
OPERAND1 OPERAND->SLX . . .








: SPEICHERHOL ( l --> addr )
  ERGEBNIS @ 2DUP !
  1+ 2DUP + ERGEBNIS !
  2DUP SWAP 0 FILL
  SWAP DROP
ERGEBNIS @ SPEICHERENDE @ LT NOT IF 0369 ERROR END_IF
  ;


: 2OPERANDEN->2SLX ( op1 op2 --> sx lx ax sy ly ay az )
  OPERAND2 !
  OPERAND1 !
  OPERAND1 OPERAND->SLX
  OVER >R
  OPERAND2 OPERAND->SLX
  OVER R> + 1+
  SPEICHERHOL
  ;

77 88 2OPERANDEN->2SLX . . . . . . .
77 5800 2OPERANDEN->2SLX . . . . . . .
</sekt>

<sekt inhalt="N+ N- N* N/MOD N.">
: N+ ( x y --> z )
  2OPERANDEN->2SLX ADDIER SLX->ERGEBNIS ;
: N- ( x y --> z )
  MINUS N+ ;
: N* ( x y --> z )
  2OPERANDEN->2SLX SMUL SLX->ERGEBNIS ;


IMMEDIATE: RECURSE LFA @ 4 + COMPILE, ;
: N/MOD ( x y --> r q )
  DUP 0= IF 0 ERROR END_IF
  DUP OPERAND1 !
  OPERAND1 OPERAND->SLX 
  ROT DROP OVER + 1 - @ ( ly ty )
  SWAP 1 > IF
    1 BEGIN OVER 0LT NOT WHILE 
      SWAP DUP + SWAP DUP N+ REPEAT
    SWAP DROP DUP SCHIEB !
    ROT OVER N*
    ROT ROT N*
    ELSE DROP 1 SCHIEB ! END_IF 
  2OPERANDEN->2SLX SDIV
  SLX->ERGEBNIS >R 
  SLX->ERGEBNIS R>
  SCHIEB @ 1 - IF 
    SWAP SCHIEB @ RECURSE SWAP DROP
    SWAP END_IF
  ;

: HG0. ( n -->  /hexstring/ )
  0 >R
  SHL16 DUP IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT ELSE DROP END_IF
  SHL16 DIG EMIT DROP R> DROP ;

: N. ( n --> ) ( erstmal nur hexadezimale Ausgabe )
  OPERAND1 !
  OPERAND1 OPERAND->SLX ( sx lx ax )
  ROT IF ." -" END_IF
  OVER + 
  1 - DUP @ HG0. SWAP 1 - SWAP
  BEGIN OVER WHILE 1 - DUP @ HG. SWAP 1 - SWAP REPEAT DROP
  DROP 
  20 EMIT
  ;

1111 1111 N* N.

: NB. SWAP N. N. ;



7 3 N/MOD N. N. 
3333 DUP N* DUP N* 10 N* DUP N.
3333 DUP N* 10 N* DUP N.
N/MOD NB.
3333 DUP N* N.

1111 DUP N* 8 N* DUP N.
1111 8 N* DUP N.
N/MOD NB.

1111 DUP N* DUP N.
1111 DUP N.
N/MOD NB.
</sekt>

<sekt inhalt="Zwischenergebnisse nicht unnötig speichern">
ZAHLENSPEICHER @ VARIABLE BLOCKANFANG
ZAHLENSPEICHER @ VARIABLE BLOCKENDE
: NEBENRECHNUNG ( --> erg ) ERGEBNIS @ ;
: HAUPTRECHNUNG ( erg --> ) ERGEBNIS ! ;
: RECHENBLOCK BLOCKENDE @ BLOCKANFANG !
  ERGEBNIS @ BLOCKENDE ! ;
: INIT ZAHLENSPEICHER @ ERGEBNIS ! RECHENBLOCK RECHENBLOCK ;
INIT

: A+0 ( a --> a+0 ) 
  OPERAND1 !
  OPERAND1 OPERAND->SLX
  OVER ERGEBNIS @ 1+ SWAP MOVE
  ERGEBNIS @ 1+ OVER 1+ ERGEBNIS +! ( noch nicht ganz )
  SLX->ERGEBNIS
  ;
: B+0 ( a b --> a+0 b+0 )
  SWAP A+0 SWAP A+0 ;
</sekt>



<sekt inhalt="Anwenden in N/ NMOD NGGT NBK...">
: N/ ( b d --> q )
  NEBENRECHNUNG ROT ROT 
  N/MOD SWAP DROP
  SWAP HAUPTRECHNUNG A+0
  ;
: NMOD ( b d --> r ) 
  NEBENRECHNUNG ROT ROT 
  N/MOD DROP 
  SWAP HAUPTRECHNUNG A+0
  ;

: NGGT ( a b --> ggt )
  NEBENRECHNUNG ROT ROT
  BEGIN DUP WHILE
    SWAP OVER NMOD REPEAT DROP 
  SWAP HAUPTRECHNUNG A+0 ;
: NBK ( a b --> a/ggt b/ggt ) 
  NEBENRECHNUNG ROT ROT
  2DUP NGGT ROT OVER N/ ROT ROT N/ 
  ROT HAUPTRECHNUNG B+0 ;



777 99 NBK NB.




( je einmal N* und N+ in NNUMBER )
: NNUMBER ( baddr n --> a faddr )
  NEBENRECHNUNG ROT ROT
  7 LOCAL ( L3 L4 nicht verwendet
  L1 ! L0 !
  0 L1 @ IF
    DUP L2 ! 1 L5 ! ( Vorzeichen )
    BEGIN ( M23 Vorzeichen gucken )
      -1 L6 ! 
      L0 @ L2 @ + C@
      2B ( 43 2B ) = IF L2 @ 1+ L2 ! 0 L6 ! ELSE
        L0 @ L2 @ + C@
        2D ( 45 2D ) = IF L2 @ 1+ L2 !
          0 L6 !
          L5 @ MINUS L5 ! END_IF
        END_IF
      L6 @ UNTIL
    L2 @ L1 @ LT IF
      BEGIN
        L0 @ L2 @ + C@
        DUP IF ( oo L1 auf Bytes )
          DIGIT NOT IF DROP L1 @ MINUS L1 ! ELSE
            SWAP BASE @ N* N+
            L2 @ 1+ L2 ! 
            END_IF
          ELSE DROP L2 @ L1 ! END_IF
        L2 @ L1 @ LT NOT UNTIL
      END_IF ( M19 )
    END_IF ( M19 )
  L5 @ 0LT IF MINUS END_IF
  L2 @ L1 @ - ( oo noch kein fadr !!!!!!!!!!!! siehe NNUMBER )
  DUP IF DROP L0 @ L2 @ + END_IF ( jetzt faddr )
  END_LOCAL
  ROT HAUPTRECHNUNG SWAP A+0 SWAP
  ;

22 WORD: N" ( /number/  --> n ) NNUMBER DROP ;



( REPLACE: NUMBER NNUMBER ;

N" 111111111111111" DUP N* DUP N.
N" 111111111111111" DUP N.
N/MOD NB.

N" 0026D4346A00" DUP N.
N" 00000FC82800" DUP N.
2DUP N/MOD NB.
2DUP NBK NB. 
( richtig wäre D6A2200 275 bei N/MOD )
( richtig wäre 3135 14 bei NBK )

N" 00A7426290A8C945E959A780" DUP N.
N" 000002330657FDD698" DUP N.
N/MOD NB. 
( richtig wäre 158B5843D5ED0 4C0CF598D2 )
( und nicht   0325AF2C3F8838 4C0CF598D3 )

( als vorlaeufigen Abschluss nochmal )
" 111111111111111" NNUMBER DROP DUP N* N.

N" 000002330657FDD698" N" 4C0CF598D3" N* N.
N" 000002330657FDD698" N" 4C0CF598D2" N* N.




: N^ ( a n --> a^n )
  NEBENRECHNUNG ROT ROT ( erg a n )
  4 LOCAL
  DUP 0LT IF 12 ERROR END_IF    
  2           ( a n 2 )        
  L3 ! L2 ! L1 !    (  R1-3: a  n  2 )
  1           ( p=1          a  n  2 )
  BEGIN       ( p            a  n  2 )
    L2 @ L3 @ ( p n 2        a  n  2 )
    /MOD      ( p r n/2      a  n  2 )
    L2 !      ( p r          a n/2 2 )
    IF        ( p            a n/2 2 )
      L1 @    ( p a          a n/2 2 )
      N*      ( p*a          a n/2 2 )
      END_IF  ( p*a          a n/2 2 )
    L2 @      ( p*a n/2      a n/2 2 )
    WHILE     ( p*a          a n/2 2 )
      L1 @    ( p*a a        a n/2 2 )
      L1 @    ( p*a a a      a n/2 2 )
      N*      ( p*a a*a      a n/2 2 )
      L1 !    ( p*a        a*a n/2 2 )
      REPEAT  ( p*a        a*a n/2 2 )
  END_LOCAL   ( a^n )
  SWAP HAUPTRECHNUNG A+0
  ;           ( a^n )


3333 2 N^ 10 N* N.
1111 2 N^ N.


10 20 N^ 10 10 N^ DUP -1 N+ SWAP 1 N+ N* N- N.
</sekt>

<sekt inhalt="nochmal N. für beliebige Zahlenbasis">
: N. ( a -->  /zahl/ )
  BASE @ 10 = IF N. ELSE
    NEBENRECHNUNG SWAP
    DUP 0LT IF MINUS ." -" END_IF
    DUP 0= IF ." 0 " DROP ELSE
      -1 SWAP ( Stapelmarkierung )
      BEGIN DUP WHILE BASE @ N/MOD REPEAT DROP
      BEGIN DUP 0LT NOT WHILE 30 + DUP 39 > IF 7 + END_IF EMIT REPEAT
      20 EMIT DROP END_IF
    HAUPTRECHNUNG
    END_IF
  ;

: NB. SWAP N. N. ;

777 99 NBK NB.
INIT
</sekt>

<sekt inhalt="Array-Objekte">
: ZERLEG ( a --> adr i )
  3FFF AND DUP 1+ SWAP @ ;

N" 111111111111111" DUP N* DUP N.
DUP ZERLEG SWAP . .

: OBJ? ( a --> flag )
  ABS DUP 4000 LT IF DROP 0 ELSE
    ZERLEG SWAP DROP 4000 LT IF 0 ELSE -1 
      END_IF END_IF
  ;

: L ( a i -> b ) OVER OBJ? IF
    SWAP ZERLEG 3FFF AND ( i adr j )
    ROT 2DUP ( adr j i j i )
    > IF SWAP DROP + @ ELSE 2DROP DROP 0 END_IF
    ELSE IF DROP 0 END_IF END_IF ;

: G ( a i -> a i b ) 2DUP L ;

: H ( a i b --> a' )
  DUP >R
  ROT ROT ( b a i )
  OVER OBJ? 0= OVER 0= AND R> OBJ? 0= AND IF 2DROP ELSE
    OVER OBJ? 0= IF 
      DUP 1+ SPEICHERHOL ( b a i addrneu )
      ROT OVER ! ( b i addrneu )
(      OVER 1+ OVER 1 - ! ( b i addrneu ( aha, macht schon SPEICHERHOL )
      4000 OVER 1 - +! ( das ist jetzt neu fuer OBJ? )
      DUP >R + ! R> ( addrneu )
      1 - 4000 +
      ELSE
        OVER                 ( b a i a )
        ZERLEG 3FFF AND      ( b a i addr j )
        ROT                  ( b a addr j i )
        2DUP > IF SWAP DROP ROT >R + ! R> ELSE
          DUP 1+ SPEICHERHOL ( b a addr j i addrneu )
          SWAP >R DUP >R     ( b a addr j addrneu      addrneu i )
          SWAP MOVE DROP R>  ( b addrneu            i )
(          R 1+ OVER 1 - !    ( b addrneu                i )
          4000 OVER 1 - +!   ( das ist jetzt neu fuer OBJ? )
          SWAP OVER R> + !   ( addrneu )
          1 - 4000 +         ( a' )
          END_IF
        ZERLEG 3FFF AND      ( adr l )
        BEGIN 2DUP + 1 - @ 0= OVER 1 > AND WHILE 1 - REPEAT ( adr lneu )
        OVER @ OBJ? 0= OVER 1 = AND IF DROP @ ELSE
          SWAP 1 - SWAP      ( addr-1 lneu )
          4000 + OVER ! 4000 +
          END_IF  
        END_IF
    END_IF
  ;
  
: O. ( obj --> )
  DUP OBJ? IF
    ." [ "
    ZERLEG 3FFF AND OVER + SWAP ( eadr+1 aadr )
    BEGIN 2DUP > WHILE DUP @ RECURSE 1 + REPEAT 2DROP
     ." ] "
    ELSE N. END_IF
  ;

7 DUP O.
2 9 H DUP O.
3 11 H DUP O.
1 4 1 6 H H DUP O.
1 G 2 88 H H DUP O. 
1 G 2 0 H H DUP O.
0 G 2 1987 H H DUP O.
1 0 H DUP O.
3 0 H DUP O.
2 0 H DUP O.
2 2444 H DUP O.
0 N" 7777777" H DUP O.
2 0 H DUP O.


0
0 0 0 1 H 1 2 H 2 5 H H DUP O.
1 0 0 3 H 1 4 H 2 8 H H DUP O.
2 0 0 9 H 1 2 H 2 1 H H CR DUP O.

0 1 4 H DUP O.
0 0 0 1 4 H H O.

0 
0 0 0 60 H 1 30 H 2 20 H H DUP O.
1 0 0 30 H 1 20 H 2 15 H H DUP O.
2 0 0 20 H 1 15 H 2 12 H H CR DUP O.
</sekt>

<sekt inhalt="Invertieren">
0 VARIABLE SPMERK
: [ ( ---> spmerk )
  SPMERK @ SP @ SPMERK !
  ;

: ] ( spmerk a b c d ... z --> matrix )
  0 BEGIN SP @ 1 - SPMERK @ - WHILE
    SP @ 2 - SPMERK @ - ROT H REPEAT
  SWAP SPMERK !
  ;

(   zuallerletzt nochmal NEBENRECHNUNG checken zuguterletzt dann auch noch B Y Z )
( NENNER als LOCAL und O. rein, uff, das ist ein Brocken. .. L0 war doch zuviel... )

: INVERTIEREN ( matrix dim --> invmat nenner )
  ( L0=mat L1=N L2=i L3=j L4=k L5=Y L6=Z L7=alternenner )
  8 LOCAL
  L1 ! L0 ! 0 L5 ! 0 L6 !
  L0 @ 1 ( mat nenner )
  L1 @ L2 ! BEGIN -1 L2 +!
    L7 ! ( mat )
    L0 @ L2 @ L L2 @ L ( mat neuernenner )
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L L2 @ L L5 @ L3 @ ROT H L5 !
      OVER L2 @ L L3 @ L L6 @ L3 @ ROT H L6 !
      L3 @ 0= UNTIL
    L5 @ L2 @ L L7 @ N+ L5 @ L2 @ ROT H L5 !
    L6 @ L2 @ L L7 @ N- L6 @ L2 @ ROT H L6 !
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L ( mat nenner mat[L3] )
      L1 @ L4 ! BEGIN -1 L4 +!
        NEBENRECHNUNG ROT ROT SWAP ( mat erg mat[L3] nenner )
        OVER L4 @ L OVER N*
        L5 @ L3 @ L L6 @ L4 @ L N* N-
        L7 @ N/ ( mat erg mat[L3] nenner bijneu )
        2SWAP SWAP ( mat nenner bijneu mat[L3] erg )
        HAUPTRECHNUNG SWAP A+0 ( mat nenner mat[L3] bijneu+0 )
        SWAP L4 @ ROT H ( mat nenner mat[L3]neu )
        L4 @ 0= UNTIL
      ROT L3 @ ROT H SWAP ( matneu nenner )
      L3 @ 0= UNTIL
    ( RECHENBLOCK )
    L2 @ 0= UNTIL
  END_LOCAL
  ;


( so und jetzt anwenden )

[ [ 3C 1E 14 ] ( dezimal 60 30 20 )
  [ 1E 14 0F ] ( dezimal 30 20 15 )
  [ 14 0F 0C ] ( dezimal 20 15 12 )
  ] 3
OVER O. DUP .
INVERTIEREN
OVER O. DUP N.
( herauskommen muss dabei )
(             [ [ F -3C 32 ] [ -3C 140 -12C ] [ 32 -12C 12C ] ] 0064 )
( dezimal        15 -60 ...                                      100 )


( paar Vandermonde-Matrizen invertieren: )
INIT
[ [ 1 1 1 1 ]
  [ 2 1 N^ 2 2 N^ 2 3 N^ 2 4 N^ ]
  [ 3 1 N^ 3 2 N^ 3 3 N^ 3 4 N^ ]
  [ 4 1 N^ 4 2 N^ 4 3 N^ 4 4 N^ ]
  ]
4 INVERTIEREN
OVER O. DUP N.
ERGEBNIS ?
( herauskommen soll [ [ 480 -360 180 -48 ] [ -4E0 558 -2A0 84 ] [ 1B0 -240 150 -48 ] )

INIT
[ [ 1 1 1 1 1 ]
  [ 2 1 N^ 2 2 N^ 2 3 N^ 2 4 N^ 2 5 N^ ]
  [ 3 1 N^ 3 2 N^ 3 3 N^ 3 4 N^ 3 5 N^ ]
  [ 4 1 N^ 4 2 N^ 4 3 N^ 4 4 N^ 4 5 N^ ]
  [ 5 1 N^ 5 2 N^ 5 3 N^ 5 4 N^ 5 5 N^ ]
  ]
5 INVERTIEREN
OVER O. DUP N.
ERGEBNIS ?
( herauskommen soll  [ [ 2A300 -2A300 ... ] ] 8700 )

INIT
[ [ 1 1 1 1 1 1 ]
  [ 2 1 N^ 2 2 N^ 2 3 N^ 2 4 N^ 2 5 N^ 2 6 N^ ]
  [ 3 1 N^ 3 2 N^ 3 3 N^ 3 4 N^ 3 5 N^ 3 6 N^ ]
  [ 4 1 N^ 4 2 N^ 4 3 N^ 4 4 N^ 4 5 N^ 4 6 N^ ]
  [ 5 1 N^ 5 2 N^ 5 3 N^ 5 4 N^ 5 5 N^ 5 6 N^ ]
  [ 6 1 N^ 6 2 N^ 6 3 N^ 6 4 N^ 6 5 N^ 6 6 N^ ]
  ]
6 INVERTIEREN
OVER O. DUP N.
ERGEBNIS ?
( herauskommen soll  [ [ 8E62000 -B1FA800 ... ] ] 17BB000 )

INIT
[ [ 1 1 1 1 1 1 1 ]
  [ 2 1 N^ 2 2 N^ 2 3 N^ 2 4 N^ 2 5 N^ 2 6 N^ 2 7 N^ ]
  [ 3 1 N^ 3 2 N^ 3 3 N^ 3 4 N^ 3 5 N^ 3 6 N^ 3 7 N^ ]
  [ 4 1 N^ 4 2 N^ 4 3 N^ 4 4 N^ 4 5 N^ 4 6 N^ 4 7 N^ ]
  [ 5 1 N^ 5 2 N^ 5 3 N^ 5 4 N^ 5 5 N^ 5 6 N^ 5 7 N^ ]
  [ 6 1 N^ 6 2 N^ 6 3 N^ 6 4 N^ 6 5 N^ 6 6 N^ 6 7 N^ ]
  [ 7 1 N^ 7 2 N^ 7 3 N^ 7 4 N^ 7 5 N^ 7 6 N^ 7 7 N^ ]
  ]
7 INVERTIEREN
OVER O. DUP N.
ERGEBNIS ?
( herauskommen soll  [ [ CC65AF0000 -13298868000 ... ] ] 1D33190000 )

INIT
[ [ 1 1 1 1 1 1 1 1 ]
  [ 2 1 N^ 2 2 N^ 2 3 N^ 2 4 N^ 2 5 N^ 2 6 N^ 2 7 N^ 2 8 N^ ]
  [ 3 1 N^ 3 2 N^ 3 3 N^ 3 4 N^ 3 5 N^ 3 6 N^ 3 7 N^ 3 8 N^ ]
  [ 4 1 N^ 4 2 N^ 4 3 N^ 4 4 N^ 4 5 N^ 4 6 N^ 4 7 N^ 4 8 N^ ]
  [ 5 1 N^ 5 2 N^ 5 3 N^ 5 4 N^ 5 5 N^ 5 6 N^ 5 7 N^ 5 8 N^ ]
  [ 6 1 N^ 6 2 N^ 6 3 N^ 6 4 N^ 6 5 N^ 6 6 N^ 6 7 N^ 6 8 N^ ]
  [ 7 1 N^ 7 2 N^ 7 3 N^ 7 4 N^ 7 5 N^ 7 6 N^ 7 7 N^ 7 8 N^ ]
  [ 8 1 N^ 8 2 N^ 8 3 N^ 8 4 N^ 8 5 N^ 8 6 N^ 8 7 N^ 8 8 N^ ]
  ]
8 INVERTIEREN
OVER O. DUP N.
ERGEBNIS ?
( herauskommen soll  [ [ 8FB77F0C000000 -FB811E55000000 ... ] ] 11F6EFE1800000 )

( mehr geht erstmal nicht weil nicht mehr Platz )
</sekt>

<sekt inhalt="Reste die auch weggelassen werden können, wenn alles geht">
: VLIST
  LFA @ BEGIN 
    DUP 1+ @ OVER 2 + @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ + REPEAT
  DROP ;

: WLIST
  LFA @ BEGIN ( CR ) DUP .
    DUP 1+ @ OVER 2 + @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ + REPEAT
  DROP
  ;

A003 CONSTANT RETURN
: REPLACE: ( /name/ ) 
  CSP! ( oo )
  20 WORD FIND DUP IF 
    LCFA DROP 1+ ( pfa
(    HERE OVER - 1 - JRBIT XSETBT SWAP !
    HERE SWAP DP ! DUP COMPILE, RETURN , DP !
    1 STAT !
    ELSE 2DROP 3 ERROR END_IF ;

: FORGET ( /name/ )
  20 WORD FIND IF 
    DP !
    HERE DUP @ + LFA !
    HERE 1+ @ BZEIG !
    ELSE DROP ." nicht gefunden " END_IF
  ;

: FEHLERTEXT ( n --> n )
  CR
  DUP 0 = IF ." Division durch Null" END_IF
  DUP 3 = IF ." Wort nicht definiert" END_IF
  DUP 6 = IF ." Eingabezeile zu lang" END_IF
  DUP 9 = IF ." Strukturfehler in IF END_IF BEGIN UNTIL DO LOOP " END_IF
  DUP 12 = IF ." negativer Exponent" END_IF
  DUP 369 = IF ." Zahlenspeicher voll" END_IF
  DUP 1234 = IF ." große ganze Zahlen kompilieren geht momentan nicht, siehe TESTFUERNEUES.TXT" END_IF
  ;

( ganz neu: Steuerungstasten: ^A bis ^G, weiter ^H=^A ^L=^B ... )
18 8 0 FILL
: STRG: : HERE 3 - DUP . @ 1+ DUP . @ DUP . 40 - HERE SWAP 7 AND 18 + ! ;
STRG: ^G 7 EMIT ." /1xPIEP/" ;
STRG: ^F 7 EMIT ." QUIT" QUIT ;
STRG: ^A ." Angehalten für genau eine Eingabezeile: " 
  CR FA00 100 EXPECT INTERPRET ." ok";

: QUERY ( adr --> n ) TIB @ 100 EXPECT ;

IMMEDIATE: (*REM*) 
  3C EMIT ." /ok>"
  BEGIN CR QUERY " (*END*)" Z= UNTIL
  3C EMIT ." ok>"
  ;
</sekt>

<sekt inhalt="Reste, die schon weggelassen sind">
(*REM*)
  RAMP1 VARIABLE RAMP3 ( RAMP3 TIB RAMP1
: RAMBUF ( /name/  n --> )
  MINUS RAMP3 +! RAMP3 @ CONSTANT ; ( oo INDVAR muss da her )

( - LOOP's - sind aber sehr langsam )
: I RP @ 1 + @ ;
: J RP @ 3 + @ ;
: K RP @ 5 + @ ;
: (DO) SWAP R> ROT ROT >R >R >R ;
: (LOOP) R> R> 1+ DUP R LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R ;
: (+LOOP) R> R>  ROT DUP  0LT IF + R OVER
  ELSE + DUP R END_IF LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R  ;
IMMEDIATE: DO COMPILE (DO) HERE ;
IMMEDIATE: LOOP COMPILE (LOOP) 0BRANCH, ;
IMMEDIATE: +LOOP COMPILE (+LOOP) 0BRANCH, ;
( : LL 0 DO I . LOOP ; 7 LL ( ok geht )


IMMEDIATE: () 0 WORD 2DROP ;
: B. ( a b --> ) SWAP . . ;
: 2@ ( adr --> a b )
  DUP 1+ @ SWAP @ ;
: 2! ( a b adr --> )
  SWAP OVER ! 1+ ! ;
: 2? 2@ B. ;

: LDUMP LFA @ HERE OVER - DUMP ;

A012 MCODE D+
A013 MCODE D-


( - paar Geraeteadressen: )
D004 CONSTANT UHR
D005 CONSTANT SWTI
D00D CONSTANT UHRL
2D05 CONSTANT XOFFINPUT

( - "Platinen befestigen und entfernen" )
20 RAMBUF TLISTE
TLISTE VARIABLE TLISTENZEIGER
: TLISTY 
  TLISTENZEIGER @ TLISTE BEGIN 
    DUP @ CR DUP . 3 - 2@ SWAP TYPE 
    1 + 2DUP = UNTIL 2DROP ;

0 VARIABLE REMOPFA
0 VARIABLE STATMERK
0 VARIABLE EXXIUHR
: EXXI
  UHRL @ >R
  STAT @ STATMERK ! 0 STAT ! ( eigentlich >R )
  TLISTE
  BEGIN DUP TLISTENZEIGER @ LT WHILE
    DUP >R @ EXECUTE R> 1+ REPEAT DROP
  STATMERK @ STAT ! 
  UHRL @ R> - EXXIUHR ! 
  ;
( ' EXXI 6 1+ - 6000 OR 6 !
' EXXI 4000 + 16 ! ( CR geht momentan +F9XX )

: ENTFERNE 
  20 WORD FIND LCFA DROP 1+
  ( DUP 0= IF 3 ERROR END_IF )
  0 REMOPFA !
  TLISTENZEIGER @ TLISTE > IF
    TLISTENZEIGER @ TLISTE DO
      DUP I @ = IF
        1 REMOPFA !
        -1 TLISTENZEIGER +!
        END_IF
      REMOPFA @ IF
        I 1+ @ I !
        END_IF
      LOOP END_IF
  REMOPFA !
  ;
  
: BEFESTIGE ENTFERNE
  REMOPFA @ TLISTENZEIGER @ !
  1 TLISTENZEIGER +! 
  ;


: DABS ( h l --> h' l' )
  OVER 0LT IF 0 0 2SWAP D- END_IF ;


( CASEOFS aus'm PSION: )
: CASEOFS ( n  /name/ --> )
  DUP RAMBUF
  0 DO
    0 I RAMP3 @ + !
    LOOP
  ;

: CASEOF: ( fn en --> )
  + HERE DPMERK @ - SWAP !
  CSP! 1 STAT !
  ;

: CASEOF ( fn en --> )
  + @ DUP IF
    DPMERK @ + EXECUTE
    ELSE DROP END_IF ;

( - CASE )
( : BIT ( i n --> bit )
(   2 ROT DUP 0LT IF 99 ERROR ELSE 
(   ^ AND 0= 1 + END_IF ; 

: (OF) ( n r i --> f r' )
  ROT = DUP ROT OR ;
: (RANGE-OF) ( n1 n2 r i --> f r' )
  DUP >R ROT > ROT R> > OR 0= DUP ROT OR ;
( : (BIT-OF) ( n r i --> f r' )
(   ROT BIT DUP ROT OR ;

IMMEDIATE: CASE ( n --> )
  " >R 0 >R" 
  INTERPRET ;
IMMEDIATE: END_CASE ( --> )
  " R> R> 2DROP" 
  INTERPRET ;
IMMEDIATE: OF ( n --> )
  " R> R (OF) >R IF" 
  INTERPRET ;              
IMMEDIATE: RANGE-OF ( n1 n2 --> )
  " R> R (RANGE-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: BIT-OF ( m --> )
  " R> R (BIT-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: ELSEOF ( --> )
  " R 0= IF" INTERPRET ;
IMMEDIATE: END_OF ( --> )
  " END_IF" INTERPRET ;
: ERR ." keine gültige RAM-Adresse" QUIT ;
' ERR 4000 OR 22 !
' ERR 4000 OR 20 !

IMMEDIATE: /; 0 STAT ! CSP? HERE 1 - @ 800 OR HERE 1 - ! SMUDGE [ SMUDGE ] ; 
( : T 77 88 DROP /; 
( ' T 8 DUMP
( : W PAUSENBIT ! /;
( ' W 8 DUMP


( Ausgabe von ESCAPE-Sequenzen: sie vertragen sich aber nicht mit xml, besser CSI nehmen )
20 WORD: ESC 1B EMIT BEGIN OVER C@ EMIT SWAP 1 + SWAP 1 - DUP 0= UNTIL DROP ;
ESC ]0;FORTY-FORTH 07 EMIT ( 07 EMIT schließt ]
: FESTPOSITION ESC [s ESC [1;1H ESC [31m ; ( saveC Pos1,1 redcolor
: RUCKPOSITION ESC [u ESC [39m ; ( restoreC defaultcolor

( Alternativer Start mit ESCAPE-Sequenzen )

: QUIT2 
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ESC [34m ." ok" END_IF CR ESC [39m 
    TIB @ 100 EXPECT ESC [36m INTERPRET 
    AGAIN ;

( REPLACE: QUIT QUIT2 ;
( QUIT

: QUIT3
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ."   " END_IF
    CR  
    CRBIT @ 2 AND IF 3C EMIT ." /ok>" END_IF
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 36 EMIT 6D EMIT END_IF
    TIB @ 100 EXPECT 
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 39 EMIT 6D EMIT END_IF
    CRBIT @ 2 AND IF 3C EMIT ." ok>" END_IF
    INTERPRET
    AGAIN ;


: IOSTART
  2C40 2C00 DO I @ I ! LOOP
  2D30 2D14 DO I @ I ! LOOP
  ;
IOSTART

( wozu das RBIT war? für relatives CR )
: COMPILE, ( adr --> )
  RBIT @ IF 4000 ELSE 
    DP @ 1+ - 0FFF AND 3000 END_IF
    0000 + + , ;

: a*a;; 
  A 2000 111111 FILL
  B 2000 111111 FILL
  C 4001 000000 FILL
  0 2000 A 0 2000 B C SMUL 7 EMIT ;
(*END*)
</sekt>

<sekt inhalt="DEMO">
56 89 * .
77 88 + .

( aktuelles Vokabular

VLIST

( nochmal mit Speicheradressen, vor jedem Wort steht dessen Aufruf-Adresse )

WLIST

( LED's zum Leuchten bringen, also auf Adresse 2D04 ausgeben )

2D04 CONSTANT LEDS
55 LEDS !

( erreichte Programmdresse in 0000-1FFF )

HERE .

( erreichte Adresse in Textspeicher E000-FFFF )

BZEIG ?

( aktuelle Stapelhoehe )

SP ?

SP ?

( Ein neues Wort definieren )

: H ." Hallo Welt " ;

H

( Bedingung IF )

: W ( n --> ) 
  ." Das ist eine " 
  1 AND IF ." un" END_IF 
  ." gerade Zahl " ; 

7 W
8 W

( Programmschleifen, die für DO LOOP ist aber momentan stillgelegt. )

( : X ( n --> )
(   0 DO I . LOOP ;
( 13 X 

( oder )

: Y ( n --> )
  0 BEGIN DUP . 1+ 2DUP = UNTIL 2DROP ;

13 Y

( oder )

: Z ( n --> )
  0 BEGIN 2DUP > WHILE DUP . 1+ REPEAT 2DROP ;

13 Z

( alles ab LEDS wieder vergessen )

HERE . BZEIG ?
FORGET LEDS
HERE . BZEIG ?









( Also an der Stelle nach FFINIT1SMUL.TXT hab ich jetzt )
( N" ( /number/  -> n        liest bis " eine grosse ganze Zahl ein
(                            kleine ganze Zahlen wie bisher eingeben
( N+ N- N* N/ N/MOD NMOD N^  und rechnet damit
( N.   a -->                 und gibt sie aus
( NBK  a b --> a' b'         Kürzen
( NGGT a b --> ggt           groesster gemeinsamer Teiler
( 
( also direkt eingeben und mit + - * / rechnen geht hier noch nicht


( ERGEBNIS ist unpassend gewählter Variablenname, 
( bezeichnet ab welcher Adresse das nächste Ergebnis gespeichert wird,
( Platz dafür ist von 1400H bis 1FFFH, aktuell erreicht: )
 
ERGEBNIS ? ( Zahlenspeicher gefuellt bis ) 

ZAHLENSPEICHER @ ERGEBNIS ! ( Zahlenspeicher leeren )

ERGEBNIS ?

N" 111111111111111" DUP N* N.

ERGEBNIS ?

( dritte binomische Formel 10^20-{10^10+1}*{10^10-1}=1 )
10 20 N^ 10 10 N^ 1 N- 10 10 N^ 1 N+ N* N- N.

ERGEBNIS ?


( Zahlenbasis wechseln )

: HEX 10 BASE ! ;
: DECIMAL 0A BASE ! ;

HEX N" 10000"
DECIMAL DUP N.
HEX DUP N.

HEX N" 100000000"
DECIMAL DUP N.
HEX DUP N.
</sekt>

<sekt inhalt="in den Zustand für Step_11 bringen und wieder RAM generieren">
: NLIT, ( a --> ) DUP 3FFF > OVER C000 LT OR IF 1234 ERROR END_IF , ;
REPLACE: LIT, NLIT, ; 
REPLACE: NUMBER NNUMBER ;
: M. . ; : M+ + ; : M- - ; : M* * ; : M/ / ; : M/MOD /MOD ; : MMOD MOD ;
: . O. ; : + N+ ; : - N- ; : * N* ; : / N/ ; : /MOD N/MOD : : MOD NMOD ; 
: GGT NGGT ; : BK NBK ; : ^ N^ ; : ? @ . ;

( jetzt rechnen auch + - * / mit großen ganzen Zahlen, 
( allerdings beim Compilieren von großen ganzen Zahlen im Moment noch 1234 ERROR


111111111111111 DUP * .

( an der Stelle Programm-VHDL-Quelltext für Step_11 ausgeben )
HEX INIT 
HERE 0 0 DUMPZ           ( generiert progRAM für P20_FFP.vhd Step_11
BZEIG @ BANF @ -1 DUMPZ  ( generiert byteRAM für P20_FFP.vhd Step_11
3000 2C00 0 DUMPZ        ( generiert stapR   für P20_FFP.vhd Step_11
</sekt>

<sekt inhalt="noch ein wenig DEMO">
111111111111111 DUP * .

( jetzt eine Matrix invertieren )

DECIMAL

[ [ 1 1 ^ 1 2 ^ 1 3 ^ 1 1 ^ ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ ]
  ] 
DUP .
4 INVERTIEREN ( mat dim --> invmat nenner )
OVER .
DUP .
( Ergebnis sollte sein: OVER .      )
(      [ [ 1152 -864 384 -72 ]      )
(        [ -1248 1368 -672 132 ]    ) 
(        [ 432 -576 336 -72 ]       )
(        [ -48 72 -48 12 ] ] ok     )
( und gemeinsamer Nenner: DUP . 288 )
</sekt>
</FFINIT2>
</INIT>
