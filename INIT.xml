<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="INIT.xsl" ?>
<!DOCTYPE INIT SYSTEM "INIT.DTD">
<INIT>
<AXIOME>
<sekt inhalt="Axiome (sie enthalten Vorwärtsreferenzen und sind deshalb separat zusammengefasst)">
<sekt inhalt="vorab der Ablauf, was tun, wenn diese Axiome geändert werden müssen">
( wenn die Axiome so bleiben wie sie sind, ganz normal 1x hintereinanderweg compilieren )
( wenn die Axiome verändert werden sollen, dann )
  ( zuerst RESET und 1x die ursprünglichen Axiome laden )
  ( anschließend die neuen Axiome compilieren, so: )
    ( HERE 100 + DPMERK ! 3400 BANF ! )
    ( 2x neue Axiome compilieren <REF1/> )
    ( 0020 DPMERK ! 3000 BANF ! )
    ( 2x neue Axiome compilieren <REF1/> nochmal )
    ( danach alles, was nach den AXIOMEN folgt, 1x compilieren )
  ( bei verzwickten Veränderungen kann es vorkommen, )
  ( dass noch weitere Zwischenschritte eingefügt werden müssen. )
</sekt>

<sekt inhalt="Anfangszustand so herstellen wie zum Recompilieren benötigt">
( zuerst alles Notwendige wieder auf Ausgangszustand schalten )
2 2 M* DUP M* BASE !           ( HEX )
DPMERK @ DP ! BANF @ BZEIG !   ( DP und BZEIG auf Anfangswerte zurücksetzen )
' NOOP @ ' KEY !               ( EXXI ausschalten )
</sekt>

<sekt inhalt="so, mit irgendwas muss das Compilieren losgehen">
IMMEDIATE: ( 29 WORD 2DROP ;
IMMEDIATE: { 0 STAT ! ; ( war ursprünglich mal [ )  
: } 1 STAT ! ;
IMMEDIATE: COMPILE 20 WORD FIND LCFA DROP COMPILE, ;
: MLIT ( a b --> 1000*a+b ) SWAP 1000 U* SWAP DROP ;
: ABS DUP 0LT IF MINUS END_IF ;
: LIT, ( a --> ) DUP ABS 04 000 MLIT AND IF 111 ERROR END_IF , ;
COMPILE: (CONSTANT:) R> @ STAT @ IF LIT, END_IF ;
</sekt>

<sekt inhalt="Konstanten">
: CONSTANT ( /name/  c --> ) CREATE COMPILE (CONSTANT:) , SMUDGE ;

2800 CONSTANT KEYADR
2801 CONSTANT SP
2802 CONSTANT RP
2803 CONSTANT PC

2F00 CONSTANT XBIT
2F01 CONSTANT SMUDGEBIT
2F02 CONSTANT RP0 3000 RP0 !
2F03 CONSTANT IRAMADR
2F04 CONSTANT JRAMADR
2F05 CONSTANT XOFF
2F06 CONSTANT CRBZEIG BZEIG @ CRBZEIG !
2F07 CONSTANT CRDP DP @ 8 M- CRDP !

2F08 CONSTANT BASE
2F09 CONSTANT TIB
2F0A CONSTANT IN1
2F0B CONSTANT IN2
2F0C CONSTANT IN3
2F0D CONSTANT IN4
2F0E CONSTANT ERRORNR 0 ERRORNR !
2F0F CONSTANT DP
2F10 CONSTANT STAT 0 STAT !
2F11 CONSTANT LFA
2F12 CONSTANT BANF
2F13 CONSTANT BZEIG
2F14 CONSTANT DPMERK
2F15 CONSTANT CSP
2F16 CONSTANT DUBIT
2F17 CONSTANT LOCALADRESSE

VERSION 1+ CONSTANT VERSION VERSION M.
</sekt>

<sekt inhalt="Maschinencode">
( A003 CONSTANT RETURN
( 0A 003 MLIT MCODE RETURN
: RETURN 0A 003 MLIT ;
COMPILE: (MCODE:) R> STAT @ IF @ , ELSE EXECUTE END_IF ;
: MCODE CREATE COMPILE (MCODE:) , RETURN , SMUDGE ;

0A 000 MLIT MCODE MINUS
0A 001 MLIT MCODE U+
0A 002 MLIT MCODE U*
0A 00D MLIT MCODE 0=
0A 00F MLIT MCODE 0LT
0A 005 MLIT MCODE EMITCODE
0A 00B MLIT MCODE NOT
0A 008 MLIT MCODE AND
0A 00E MLIT MCODE OR
0A 007 MLIT MCODE M+
0A 009 MLIT MCODE !
0A 00A MLIT MCODE @
0B 412 MLIT MCODE SWAP
0B 502 MLIT MCODE OVER
0B 501 MLIT MCODE DUP
0B 434 MLIT MCODE ROT
0B 300 MLIT MCODE DROP
0B 43C MLIT MCODE 2SWAP
0B 60C MLIT MCODE 2OVER
0B 603 MLIT MCODE 2DUP
0B 200 MLIT MCODE 2DROP
08 000 MLIT MCODE NOOP
</sekt>

<sekt inhalt="ein Abschnitt für die Zeichenketten">
: B, ( b --> ) BZEIG @ ! 1 BZEIG +! ;
: Z, ( badr n --> ) BZEIG @ LIT, DUP ,
  BEGIN SWAP DUP @ B, 1+ SWAP 1- DUP 0= UNTIL
  2DROP 20 B, ; 
COMPILE: (WORD:) WORD STAT @ IF Z, R> COMPILE, END_IF ;
: WORD: CREATE 1 STAT ! , COMPILE (WORD:) -1 CSP +! ;
22 WORD: " ;
22 WORD: ." TYPE ;
</sekt>

<sekt inhalt="weiter mit Programmstrukturen">
: HERE DP @ ;
: JRBIT 8 ;
: JR0BIT 9 ;
( **** : XSETBT 1000 M* SWAP 0FFF AND OR ;
: XSETBT 0 1000 ROT U* SWAP DROP SWAP 0FFF AND OR ;
: ALLOT DP +! ;
: BRANCH, HERE 1+ M- JRBIT XSETBT , ;
: 0BRANCH, HERE 1+ M- JR0BIT XSETBT , ;
IMMEDIATE: BEGIN HERE ;
IMMEDIATE: AGAIN BRANCH, ;
IMMEDIATE: UNTIL 0BRANCH, ;
IMMEDIATE: IF JR0BIT 1 ALLOT HERE ;
IMMEDIATE: END_IF HERE OVER M- ROT XSETBT SWAP 1- ! ;
IMMEDIATE: ELSE 1 ALLOT COMPILE END_IF JRBIT HERE ;
IMMEDIATE: WHILE COMPILE IF ;
IMMEDIATE: REPEAT ROT COMPILE AGAIN COMPILE END_IF ;
</sekt>

<sekt inhalt="etliche kleinere Funktionen">
: C@ @ ;
: C! ! ;
: 1+ ( a --> a+1 ) 1 M+ ;
: 1- ( a --> a+1 ) -1 M+ ;
: M- MINUS M+ ;
: = M- 0= ;
: LT ( a b --> r ) M- 0LT ;
: > ( a b --> r ) SWAP LT ;
: M* ( a b --> a*b ) 0 ROT ROT U* SWAP DROP ;
: BYE BEGIN ." BYE " AGAIN ;
: +! ( a adr --> adr+1 ) SWAP OVER @ M+ SWAP ! ;
: R> RP @ 1+ @ RP @ 1+ RP 2DUP @ @ SWAP ! ! ;
: >R RP @ DUP 1- RP 2DUP @ @ SWAP DUP 1- RP ! ! ! ! ; 
: R RP @ 1+ @ ; ( bei R> >R nicht unterhalb RP speichern wegen INTXY )
: , DP @ ! 1 DP +! ;
: EXECUTE PC ! ;
: KEY BEGIN NOOP KEYCODE2 NOT WHILE DROP REPEAT ;
: EMIT ' EMITCODE EXECUTE ;
: SHL16 ( a --> t a' )
  0 SWAP 10 U* SWAP ; ( t a' = SHL a )
: DIG ( n --> c )
  DUP 0A LT IF ELSE 7 M+ END_IF 30 M+ ;
: TYPE
  BEGIN DUP WHILE
    SWAP DUP C@ EMIT 1+
    SWAP 1- REPEAT
  2DROP ;
: HG. SHL16 DIG EMIT SHL16 DIG EMIT SHL16 DIG EMIT
  SHL16 DIG EMIT DROP ;
: M. HG. 20 EMIT ;
: M? @ M. ;
: CR 
  CRDP @ DP @ M- STAT @ 0= NOT OR XBIT @ 0= NOT AND IF 
    3C EMIT ." fl>" CRDP @ M. CRBZEIG @ M. 3C EMIT ." /fl>"
    3C EMIT ." fr>" DP @ M. BZEIG @ M. 3C EMIT ." /fr>"
    DP @ CRDP ! BZEIG @ CRBZEIG ! 
    END_IF
  0A EMIT ;
: FEHLERTEXT ( n --> n ) ;
: DISABLE 
  CR ." weiter nach Taste ESCAPE "
  BEGIN 20 EMIT 8 EMIT KEY 1B = UNTIL ; 
: ERROR
  DUP ERRORNR !
  0 STAT !
  CR IN1 @ IN3 @ IN1 @ M- 1- TYPE ." ???"
  " FEHLERTEXT" INTERPRET
  CR ." ERROR - Fehler Nummer " M. 
  DISABLE QUIT ;
: CSP! SP @ CSP ! ;
: CSP? SP @ CSP @ M- IF 9 ERROR END_IF ;
</sekt>

<sekt inhalt="lokale Variablen">
: LOCAL ( n --> ) 1+ LOCALADRESSE @ OVER M- DUP LOCALADRESSE ! ! ;
: END_LOCAL ( --> ) LOCALADRESSE @ DUP @ M+ LOCALADRESSE ! ;
: L0 LOCALADRESSE @ 1+ ;
: L1 LOCALADRESSE @ 2 M+ ;
: L2 LOCALADRESSE @ 3 M+ ;
: L3 LOCALADRESSE @ 4 M+ ;
: L4 LOCALADRESSE @ 5 M+ ;
: L5 LOCALADRESSE @ 6 M+ ;
: L6 LOCALADRESSE @ 7 M+ ;
: L7 LOCALADRESSE @ 8 M+ ; ( soviele reichen schon )
</sekt>

<sekt inhalt="alles zu KEY">
IMMEDIATE: ' ( /name/ --> --> pfa ) 
  20 WORD FIND LCFA DROP 1+ STAT @ IF LIT, END_IF ; 

: INCR4 ( adr --> )
  DUP @ 1+
  DUP 3FF AND 000 = IF -400 M+ END_IF 
  SWAP !
  ;

: KEY_INT ( --> )
  KEYADR @ 
  DUP 08 LT IF 
    18 M+ @ DUP IF DUP EXECUTE END_IF
    DROP
    ELSE
      IRAMADR @ ! 
      IRAMADR INCR4
      IRAMADR @ JRAMADR @ M- 3FF AND 
      80 > IF XOFF @ 0= IF -1 XOFF ! 13 EMIT END_IF END_IF 
      END_IF
  0 KEYADR !
  ;

: KEYCODE2 ( --> c f )
  JRAMADR @ IRAMADR @ = IF 0 0 
    ELSE JRAMADR @ @ -1
    JRAMADR INCR4
    IRAMADR @ JRAMADR @ M- 3FF AND
    20 LT IF XOFF @ IF 0 XOFF ! 11 EMIT END_IF END_IF
    END_IF
  ;

' KEY_INT 04 000 MLIT OR 12 !
</sekt>

<sekt inhalt="es folgt der Interpreter">
( ESCAPE durch EXPECT durchlaufen lassen )
( und 7F in 08 umwandeln )
( und nach n Zeichen kein 0D mehr lesen )
: EXPECT ( /text/  adr n --> adr m )
  5 LOCAL
  L2 ! L1 ! L1 @ L4 !
  BEGIN
    KEY
    DUP 14 ( 20 ) ( =^T, ^R=18 ) = IF 
      DROP L1 @ C@ END_IF
    DUP 7F = IF DROP 08 END_IF
    DUP 08 = IF L4 @ L1 @ LT IF
      -1 L1 +!
      1 L2 +!
      8 EMIT 20 ( 32 ) EMIT 8 EMIT
      END_IF END_IF
(    DUP 20 ( 32 ] LT NOT OVER 08 = OR OVER 1B = OR L2 @ 0= NOT AND WHILE
      DUP 20 LT IF ( DROP ) ELSE
        -1 L2 +!
        L2 @ 0LT IF 6 ERROR END_IF
        DUP EMIT
        DUP L1 @ C! 1 L1 +!
        END_IF 
    DUP 20 LT OVER 08 = NOT AND SWAP 1B = NOT AND L2 @ 0= OR UNTIL
(      REPEAT
  20 ( 32 ) EMIT
  L4 @ L1 @ L4 @ M-
  2DUP M+ 0 SWAP C!
  END_LOCAL
  ;


: DIGIT ( z --> d r ) ( r=-1 wenn gueltig )
  ( vorher r=0 wenn gueltig!!! )
  DUP 30 ( 30 48 ) LT NOT OVER 3A ( 3A 58 ) LT AND
  OVER 41 ( 41 65 ) LT NOT OR 
  DUP IF ( z -1 wenn gueltig )
    SWAP 30 ( 30 48 ) M-
    DUP 0A LT NOT IF 7 M- END_IF
    DUP BASE @ LT NOT IF DROP DROP 0 0 END_IF
    SWAP END_IF ;

: NUMBER ( badr n --> a r )
  7 LOCAL ( L3 L4 nicht verwendet )
  L1 ! L0 !
  0 L1 @ IF
    DUP L2 ! 1 L5 ! ( Vorzeichen )
    BEGIN ( M23 Vorzeichen gucken )
      -1 L6 ! 
      L0 @ L2 @ M+ C@
      2B ( 43 2B ) = IF L2 @ 1+ L2 ! 0 L6 ! ELSE
        L0 @ L2 @ M+ C@
        2D ( 45 2D ) = IF L2 @ 1+ L2 !
          0 L6 !
          L5 @ MINUS L5 ! END_IF
        END_IF
      L6 @ UNTIL
    L2 @ L1 @ LT IF
      BEGIN
        L0 @ L2 @ M+ C@
        DUP IF ( oo L1 auf Bytes )
          DIGIT NOT IF DROP L1 @ MINUS L1 ! ELSE
            SWAP BASE @ M* M+
            L2 @ 1+ L2 ! 
            END_IF
          ELSE DROP L2 @ L1 ! END_IF
        L2 @ L1 @ LT NOT UNTIL
      END_IF ( M19 )
    END_IF ( M19 )
  L5 @ 0LT IF MINUS END_IF
  L2 @ L1 @ M- ( oo noch kein fadr )
  END_LOCAL
  ;

: WORD ( b --> adr n )
  >R
  IN3 @ IN2 !
  BEGIN 
    IN3 @ C@ R = IN3 @ IN4 @ LT AND WHILE
      1 IN3 +! REPEAT
  IN3 @ IN2 !
  BEGIN 
    IN3 @ C@ 3C = IF IN3 @ IN4 ! END_IF ( alles nach 3C ist Kommentar )
    IN3 @ C@ R = NOT IN3 @ IN4 @ LT AND WHILE
      1 IN3 +! REPEAT
  IN2 @ IN3 @ OVER M-
  DUP IF 1 IN3 +! END_IF
  R> DROP
  ;

: Z= ( adr1 n1 adr2 n2 --> r )
  >R OVER R M- IF R> DROP DROP DROP DROP 0 ELSE
    R> DROP SWAP 0 BEGIN 2DUP M- WHILE >R >R
      OVER C@ OVER C@ M- IF DROP DROP 0 0 END_IF
      DUP IF 1+ SWAP 1+ SWAP END_IF
      R> R> 1+ REPEAT 2DROP ( neu bei 16 BIT ohne DO LOOP )
    DROP IF -1 ELSE 0 END_IF
    END_IF ;
( : Z= DROP SWAP DROP SWAP @ SWAP @ = ;

: FIND ( adr n --> lfa r )
  >R >R 0 ( heisst noch nicht gefunden )
  LFA @ 
  SMUDGEBIT @ IF DUP @ M+ END_IF
  BEGIN
    DUP 1+ DUP @ ( lfa nfa adr )
    SWAP 1+ @ ( lfa adr n1 )
    ( 2DUP CR B. 2DUP TYPE
    ( BEGIN 2DUP M+ 1 M- C@ 0= WHILE 1 M- REPEAT ( ??? momentan nicht )
    R> R> 2DUP >R >R ( 0 lfa adr1 n1 adr2 n2 )
    Z= IF SWAP 0= SWAP END_IF ( heisst gefunden )
    OVER 0= OVER @ 0= NOT AND 
    OVER DUP @ M+ LFA @ = NOT AND WHILE ( wegen 2xladen )
      DUP @ M+ REPEAT
  R> DROP R>
  ROT 0= IF DROP DROP 0 0 END_IF
  ( OVER LFA @ SWAP LT IF M." *" OVER M. LFA @ M. END_IF ( vref wenn gebraucht )
  ;

: LCFA ( lfa r --> cfa r ) SWAP 3 M+ SWAP ;

: COMPILE, ( adr --> ) 04 000 MLIT OR , ;

: CREATE ( /name/  --> )
  CSP! ( Stapelbalance prüfen in ; )
  DP @ LFA @ OVER M- , LFA !
  20 WORD Z,
  1 SMUDGEBIT ! ( HERE 2 M- DUP @ MINUS SWAP ! ( UNSMUDGE )
  ;

: INTERPRET ( adr n --> ... )
  IN1 @ >R IN2 @ >R IN3 @ >R IN4 @ >R
  OVER M+ IN4 !
  DUP IN1 ! DUP IN2 ! IN3 !
  BEGIN
  ( ... qstack? Stapelpruefen )
  20 WORD
  DUP WHILE
    2DUP FIND 
    DUP IF ( gefunden )
      >R >R 2DROP R> R> LCFA DROP EXECUTE
      ELSE ( nicht gefunden )
        2DROP
        2DUP NUMBER IF ( keine Zahl )
          2DROP DROP
          3 ERROR
         ( DROP BNUMBER
         ( DUP IF DUP IN2 ! END_IF
         ( IF 3 ERROR END_IF
         ( STAT @ IF SWAP LIT, LIT, END_IF
          ELSE ( eine Zahl )
            ROT DROP SWAP DROP
            STAT @ IF LIT, END_IF ( oo LIT, fuer gr )
            END_IF
        END_IF
    REPEAT 2DROP
  R> IN4 ! R> IN3 ! R> IN2 ! R> IN1 !
  ;

: QUIT
  RP0 @ RP ! 
  XBIT @ IF 3C EMIT ." /ok>" ELSE ." ok" END_IF
  BEGIN ( im Prinzip nur BEGIN CR TIB @ 100 EXPECT INTERPRET AGAIN )
    CR 
    TIB @ 100 EXPECT
    OVER @ 3C = IF 2DROP ELSE ( xml am Zeilenanfang gleich überlesen )
      XBIT @ IF 
        3C EMIT ." ok>" 
        INTERPRET 
        3C EMIT ." /ok>" 
        ELSE
          1B EMIT 5B EMIT 33 EMIT 36 EMIT 6D EMIT
          INTERPRET 
          STAT @ 0= IF ." ok" END_IF 
          1B EMIT 5B EMIT 33 EMIT 39 EMIT 6D EMIT
          END_IF 
      END_IF
    AGAIN 
  ;


: START ." FORTY-FORTH" CR CR QUIT ;


: SMUDGE 0 SMUDGEBIT ! ( LFA @ 1+ DUP @ DUP 0LT IF MINUS END_IF SWAP ! ) ;

: (IMMEDIATE:) R> >R ;
:   (COMPILE:) R> COMPILE, ;
:          (:) R> STAT @ IF COMPILE, ELSE >R END_IF ;

: IMMEDIATE: CREATE 1 STAT ! COMPILE (IMMEDIATE:) ;
:   COMPILE: CREATE 1 STAT ! COMPILE (COMPILE:) ;
:          : CREATE 1 STAT ! COMPILE (:) ;

( das hier jetzt mit dem neuen CREATE: )
IMMEDIATE: ; 0 STAT ! CSP? RETURN , SMUDGE { SMUDGE } ; 
( tatsaechlich { SMUDGE } wegen 2x laden!!! ) 
( Ende der Axiome. Hiermit enden die Axiome. )
</sekt>

<sekt inhalt="neues Vokabular abkoppeln und Programm neu starten">
0 DPMERK @ ! ( abkoppeln )
HERE M. BZEIG M?

START
</sekt>
</sekt>
</AXIOME>

<FFINIT2>
<sekt inhalt="bis Adresse 0800H passt noch DUMPZ drauf (inzwischen nicht mehr)">
( erste Forth Erweiterungen )
( - DUMPZ )
( RAMB-Inhaltsausgabe erzeugen: )
: LG. ( n --> )
  DUBIT @ IF SHL16 DROP SHL16 DROP 
    ELSE SHL16 DIG EMIT SHL16 DIG EMIT END_IF 
  SHL16 DIG EMIT SHL16 DIG EMIT DROP ;
: NG. ( n --> )
  ." x" 22 EMIT LG. 22 EMIT ." ," ; 
: DUMPZ ( bis+1 von dubit --> )
  DUBIT ! XBIT @ >R 0 XBIT !
  " ' START " INTERPRET 04 000 MLIT OR 10 !
  CR 3C EMIT ." DUMPZ>"
  BEGIN
    CR ."   "
    0000 BEGIN
      2DUP M+
      DUP IRAMADR = IF DROP JRAMADR END_IF
      DUP LOCALADRESSE = IF DROP 2F00 2F80 ! 2F80 END_IF
      DUP XOFF = IF DROP XBIT END_IF
      @ NG. 1+ DUP 10 =
      UNTIL DROP
    ."  -- " DUP HG. ." -" DUP 0F M+ HG.
    10 M+
    2DUP > NOT UNTIL 2DROP
  CR 3C EMIT ." /DUMPZ>"
  R> XBIT !
  ;

HERE M. BZEIG M?
</sekt>

<sekt inhalt="ProgRAM und ByteRAM für Step_9 und Step_10 erstellen">
HERE 0 0 DUMPZ          ( generiert ProgRAM für P20_FFP.vhd Step_10 )
BZEIG @ 3000 -1 DUMPZ   ( generiert ByteRAM für P20_FFP.vhd Step_10 )
</sekt>

<sekt inhalt="Variablen">
2F20 CONSTANT RAMP1 RAMP1 1+ RAMP1 ! ( bis 2F17 sind neu BASE TIB ... )
: VARIABLE RAMP1 @ DUP CONSTANT DUP 1+ RAMP1 ! ! ;
</sekt>

<sekt inhalt="noch paar hilfreiche Funktionen">
: MOVE ( adr1 adr2 n --> )
  BEGIN DUP WHILE >R OVER @ OVER ! SWAP 1+ SWAP 1+ R> 1- REPEAT DROP 2DROP ;
: FILL ( adr n b --> )
  ROT ROT BEGIN DUP WHILE >R 2DUP ! 1+ R> 1- REPEAT DROP 2DROP ;

: DUMP ( addr n --> )
  BEGIN SWAP ( CR DUP M. ) DUP @ M. 1+ SWAP 1- DUP 0= UNTIL DROP ;

: MAX ( a b --> c )
  2DUP LT IF SWAP END_IF DROP ;
: MIN ( a b --> c )
  2DUP > IF SWAP END_IF DROP ;
</sekt>

<sekt inhalt="Rechenoperationen zu verschiedenen Datentypen">
( leere Tabellenfelder sind nicht in Verwendung )
<table border="1">
  <tr><th>Rechenoperation</th>        <th>16-Bit-Arithmetik</th>        <th>große ganze Zahlen</th></tr>
  <tr><td>absoluter Betrag</td>       <td>ABS ( a --> |a| ) </td>       <td>ABS ( n --> |n| )</td></tr>
  <tr><td>Addition</td>               <td>M+ ( a b --> a+b ) </td>      <td>+ ( m n --> m+n ) </td></tr>
  <tr><td>Subtraktion</td>            <td>M- ( a b --> a-b ) </td>      <td>- ( m n --> m-n ) </td></tr>
  <tr><td>Stapelspitze ausgeben</td>  <td>M. ( a -->  /string/ )</td>   <td>. ( m -->  /string/ )</td></tr>
  <tr><td>Speicherinhalt ausgeben</td><td>M? ( adr -->  /string/ )</td> <td>? ( adr -->  /string/ )</td></tr>
  <tr><td>Inkrementieren</td>         <td>1+ ( a --> a+1 ) </td>        <td></td></tr>
  <tr><td>Dekrementieren</td>         <td>1- ( a --> a+1 ) </td>        <td></td></tr>
  <tr><td>kleiner als "&lt;"</td>     <td>LT ( a b --> a&lt;b )</td>    <td></td></tr>
  <tr><td>größer als</td>             <td>> ( a b --> a>b )</td>        <td></td></tr>
  <tr><td>Maximum</td>                <td>MAX ( a b --> max )</td>      <td></td></tr>
  <tr><td>Minimum</td>                <td>MIN ( a b --> min )</td>      <td></td></tr>
  <tr><td>Division mit Rest</td>      <td>M/MOD ( a b --> q r )</td>    <td>/MOD ( m n --> q r )</td></tr>
  <tr><td>Division</td>               <td></td>                         <td>/ ( m n --> q )</td></tr>
  <tr><td>Rest</td>                   <td></td>                         <td>MOD ( m n --> r )</td></tr>
  <tr><td>Multiplikation</td>         <td></td>                         <td>* ( m n --> m*n )</td></tr>
  <tr><td>größter gemeinsamer Teiler</td><td></td>                      <td>GGT ( m n --> ggt )</td></tr>
  <tr><td>Kürzen</td>                 <td></td>                         <td>BK ( m n --> m/ggt n/ggt )</td></tr>
  <tr><td>Potenzieren</td>            <td></td>                         <td>^ ( m n --> m^n )</td></tr>
  <tr><td>Addition mit Übertrag</td>  <td>U+ ( u a b --> u' a+b+u ) </td><td></td></tr>
  <tr><td>Multiplikation mit Übertrag</td><td>U* ( u a b --> u' a*b+u ) </td><td></td></tr>
  </table>
</sekt>

<sekt inhalt="Multiplikation">
A017 MCODE MULT_I
A018 MCODE MULT_II
: SUPERMULT ( a u adrc adrb n --> a u' adrc' adrb' )
  >R
  BEGIN MULT_I MULT_II UNTIL
  R> DROP ; ( /;> )





1401 CONSTANT A
1601 CONSTANT B
1801 CONSTANT C
A 1FF 1111 FILL
B 1FF 1111 FILL
C 3FF 0000 FILL

1111 0 C B 4 SUPERMULT M. M. M. M.
C 8 DUMP





: SMUL ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3)
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ M+ 1+
  L6 @ OVER 0 FILL
  L6 @ 
  DUP L2 @ L1 @ BEGIN
    0 2OVER @ ROT ROT L5 @ L4 @ ( ... a u  adrc  adrb n )
    SUPERMULT                   ( ... a u' adrc' adrb' )
    DROP ! DROP

(    vorher: )
(    L4 @ 0 
(    BEGIN OVER WHILE SWAP 1- SWAP
(      0 SWAP 
(      L6 @ @ L5 @ @ L2 @ @ U* D+ 
(      L6 @ DUP 1+ L6 ! !
(      L5 @ 1+ L5 !
(      REPEAT
(    L6 @ ! DROP

    ROT 1+ ROT 1+ ROT 1- ( 1 L2 +! 1 L6 +!
    DUP 0= UNTIL DROP 2DROP
  END_LOCAL
  ;

C 8 0 FILL
0 2 A 0 2 B C SMUL M. M. M.
C 8 DUMP

C 201 0 FILL
0 100 A 0 100 B C SMUL M. M. M.
C 8 DUMP

C 101 0 FILL
0 80 A 0 80 B C SMUL M. M. M.
C 8 DUMP

( C 2001 0 FILL
( 0 1000 A 0 1000 B C SMUL M. M. M.
( C 8 DUMP
</sekt>

<sekt inhalt="Addition"> 
: ADDIER ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 )
         ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
  L0 @ L1 @ L4 @ MAX 1+ L6 @
  L0 @ L3 @ = IF
    0 L1 @ L4 @ MAX 0 BEGIN ROT
                 ( hier ist mal ! @ gewesen!!! )
      OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
      SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! ELSE 0 END_IF
      U+ L6 @ DUP 1+ L6 ! !
      ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP L6 @ !
    ELSE SWAP 1 M- SWAP
      1 L1 @ L4 @ MAX 0 BEGIN ROT
        OVER DUP L1 @ LT IF L2 @ DUP @ SWAP 1+ L2 ! ELSE 0 END_IF
        SWAP L4 @ LT IF L5 @ DUP @ SWAP 1+ L5 ! NOT ELSE -1 END_IF
        U+ L6 @ DUP 1+ L6 ! !
        ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP ( DUP M.
        0= IF DUP L6 !
          ROT NOT ROT ROT
          1 L1 @ L4 @ MAX 0 BEGIN ROT
            0 L6 @ @ NOT U+ 
            L6 @ DUP 1+ L6 ! !
            ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP DROP
          END_IF
      END_IF 
  END_LOCAL ;


C 8 0 FILL
0 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 5 A 0 7 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 7 A 0 3 B C ADDIER M. M. M.
C 8 DUMP

A 8 FFFF FILL
C 8 0 FILL
0 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP ( 1110 1111 0001 0000 )


A 8 2222 FILL
C 8 0 FILL
0 2 A -1 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
-1 2 A 0 2 B C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
0 2 B -1 2 A C ADDIER M. M. M.
C 8 DUMP

C 8 0 FILL
-1 2 B 0 2 A C ADDIER M. M. M.
C 8 DUMP
</sekt>

<sekt inhalt="Division">
A014 MCODE DI32 
: DIV32 ( a b d --> r q )
  10 BEGIN >R DI32 R> 1- DUP 0= UNTIL 2DROP ;
: M/MOD ( b d --> r q ) 0 ROT ROT DIV32 ;



: SDIV ( s1 l1 x1 s2 l2 x2 x3 --> s3 l3 x3 s4 l4 r4 )
       ( L0 L1 L2 L3 L4 L5 L6 )
  7 LOCAL
  L6 ! L5 ! L4 ! L3 ! L2 ! L1 ! L0 !
L1 @ L4 @ LT IF L0 @ L1 @ L2 @ 0 0 0 ELSE
  L1 @ 0 BEGIN
    L2 @ OVER M+ @ NOT OVER L6 @ M+ !
    1+ 2DUP M- 0= UNTIL 2DROP
  L6 @ L1 @ M+ L4 @ M- L2 !
  -1 L6 @ L1 @ M+ ! 1 L1 +!
  L1 @ L4 @ M- 0 BEGIN
    L2 @ L4 @ M+ @ NOT
    L2 @ L4 @ M+ 1- @ NOT
    L5 @ L4 @ M+ 1- @      ( a b c )
    DIV32 
    SWAP DROP              ( q )
    DUP L2 @ L4 @ M+ 1+ !
    0 L2 @ L5 @ L4 @       ( c ü adrc adrb n )
    SUPERMULT
    2DROP SWAP DROP
    0 L2 @ L4 @ M+ @ U+ L2 @ L4 @ M+ !
BEGIN WHILE
 1 L4 @ 0 BEGIN ROT
   OVER L2 @ OVER M+ @
   SWAP L5 @ M+ @ NOT
   U+ SWAP >R OVER L2 @ M+ ! R>
   ROT ROT 1+ 2DUP M- 0= UNTIL 2DROP
(   0 L2 @ L4 @ M+ @ U+ L2 @ L4 @ M+ !
(   DUP M. 7 EMIT
 -1 L2 @ L4 @ M+ 1+ +!
REPEAT
    -1 L2 +!
    1+ 2DUP M- 0= UNTIL 2DROP
  L4 @ 0 BEGIN
    L6 @ OVER M+ @ NOT OVER L6 @ M+ !
    1+ 2DUP M- 0= UNTIL 2DROP
  L4 @ L6 @ 1- !
  L1 @ L4 @ M- L6 @ L4 @ M+ !
( CR ." ++" L6 @ L1 @ 1+ DUMP ." ++"
  L0 @ L4 @ L6 @
  L0 @ L3 @ IF NOT END_IF
  L1 @ L4 @ M-
  L6 @ L4 @ M+ 1+
 END_IF
  END_LOCAL
  ;

( 333333 4 ^ 10 * VARIABLE NA
( 333333 DUP * 10 * VARIABLE NB
( NA @ 10 DUMP
( NA @ NB @ 2OPERANDEN->2SLX OVER M. DUP M. SDIV

654321 A !
234567 A 1+ !
000001 A 2 M+ !
432101 B !
A98765 B 1+ !

0 3 A 0 2 B C SMUL M. M. M.
C 8 DUMP

0 4 C 0 2 B A SDIV M. M. M. M. M. M.
A 8 DUMP
</sekt>

<sekt inhalt="Zahlenspeicher">
0 VARIABLE OPERAND1
0 VARIABLE OPERAND2
1800 VARIABLE ERGEBNIS
1800 VARIABLE ZAHLENSPEICHER
2000 VARIABLE SPEICHERENDE
0 VARIABLE SCHIEB


: SLX->ERGEBNIS ( sz lz az --> z )
  OVER 0= IF 2DROP DROP 0 ELSE ( 0 bei 1/7 )
    2DUP M+ BEGIN 1- DUP @ 0= NOT UNTIL 
    1+ OVER MAX ( sz lz az ez )
    ( DUP ERGEBNIS ! ( nicht wegen 0 1 OPERAND1 )
    2DUP = IF 2DROP 2DROP 0 ELSE
      OVER M- ( sz lz az lneu )
      OVER @ 0C 000 MLIT AND 0=
      OVER 1 = AND IF
        DROP @ ELSE ( warum war da -1 ERGEBNIS +! )
          OVER 1- !
          1- 04 000 MLIT OR
          END_IF 
      SWAP DROP 
      SWAP IF MINUS END_IF
      END_IF
    END_IF
  ;
0 8 C SLX->ERGEBNIS M.

: OPERAND->SLX ( op --> sx lx ax )
  DUP @ ( op x )
  DUP 0LT IF MINUS -1 ELSE 0 END_IF
  ROT ROT ( sx op xabs )
  DUP 04 000 MLIT AND IF
    SWAP DROP
    3FFF AND
    DUP @ SWAP 1+
    ELSE
      OVER ! 1 SWAP 
      END_IF
  ;

77 OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.
-77 OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.
5800 OPERAND1 !
OPERAND1 OPERAND->SLX M. M. M.








: SPEICHERHOL ( l --> addr )
  ERGEBNIS @ 2DUP !
  1+ 2DUP M+ ERGEBNIS !
  2DUP SWAP 0 FILL
  SWAP DROP
ERGEBNIS @ SPEICHERENDE @ LT NOT IF 0369 ERROR END_IF
  ;


: 2OPERANDEN->2SLX ( op1 op2 --> sx lx ax sy ly ay az )
  OPERAND2 !
  OPERAND1 !
  OPERAND1 OPERAND->SLX
  OVER >R
  OPERAND2 OPERAND->SLX
  OVER R> M+ 1+
  SPEICHERHOL
  ;

77 88 2OPERANDEN->2SLX M. M. M. M. M. M. M.
77 5800 2OPERANDEN->2SLX M. M. M. M. M. M. M.
</sekt>

<sekt inhalt="+ - * /MOD .">
: + ( x y --> z )
  2OPERANDEN->2SLX ADDIER SLX->ERGEBNIS ;
: - ( x y --> z )
  MINUS + ;
: * ( x y --> z )
  2OPERANDEN->2SLX SMUL SLX->ERGEBNIS ;


IMMEDIATE: RECURSE LFA @ 4 M+ COMPILE, ;
: /MOD ( x y --> r q )
  DUP 0= IF 0 ERROR END_IF
  DUP OPERAND1 !
  OPERAND1 OPERAND->SLX 
  ROT DROP OVER M+ 1- @ ( ly ty )
  SWAP 1 > IF
    1 BEGIN OVER 0LT NOT WHILE 
      SWAP DUP M+ SWAP DUP + REPEAT
    SWAP DROP DUP SCHIEB !
    ROT OVER *
    ROT ROT *
    ELSE DROP 1 SCHIEB ! END_IF 
  2OPERANDEN->2SLX SDIV
  SLX->ERGEBNIS >R 
  SLX->ERGEBNIS R>
  SCHIEB @ 1- IF 
    SWAP SCHIEB @ RECURSE SWAP DROP
    SWAP END_IF
  ;

: HG0. ( n -->  /hexstring/ )
  0 >R
  SHL16 DUP IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT R> DROP -1 >R ELSE DROP END_IF
  SHL16 DUP R OR IF DIG EMIT ELSE DROP END_IF
  SHL16 DIG EMIT DROP R> DROP ;

: . ( n --> ) ( erstmal nur hexadezimale Ausgabe )
  OPERAND1 !
  OPERAND1 OPERAND->SLX ( sx lx ax )
  ROT IF ." -" END_IF
  OVER M+ 
  1- DUP @ HG0. SWAP 1- SWAP
  BEGIN OVER WHILE 1- DUP @ HG. SWAP 1- SWAP REPEAT DROP
  DROP 
  20 EMIT
  ;

1111 1111 * .

: B. SWAP . . ;



7 3 /MOD . . 
3333 DUP * DUP * 10 * DUP .
3333 DUP * 10 * DUP .
/MOD B.
3333 DUP * .

1111 DUP * 8 * DUP .
1111 8 * DUP .
/MOD B.

1111 DUP * DUP .
1111 DUP .
/MOD B.
</sekt>

<sekt inhalt="Zwischenergebnisse nicht unnötig speichern">
ZAHLENSPEICHER @ VARIABLE BLOCKANFANG
ZAHLENSPEICHER @ VARIABLE BLOCKENDE
: NEBENRECHNUNG ( --> erg ) ERGEBNIS @ ;
: HAUPTRECHNUNG ( erg --> ) ERGEBNIS ! ;
: RECHENBLOCK BLOCKENDE @ BLOCKANFANG !
  ERGEBNIS @ BLOCKENDE ! ;
: INIT ZAHLENSPEICHER @ ERGEBNIS ! RECHENBLOCK RECHENBLOCK ;
INIT
ERGEBNIS M?
: A+0 ( a --> a+0 ) 
  DUP OPERAND1 !
  OPERAND1 OPERAND->SLX
  DUP OPERAND1 M- IF
    OVER ERGEBNIS @ 1+ SWAP MOVE ( SPEICHERHOL will hier nicht gehen )
    ERGEBNIS @ 1+ OVER 1+ ERGEBNIS +! ( noch nicht ganz )
    ERGEBNIS @ SPEICHERENDE @ LT NOT IF 0369 ERROR END_IF ( da ist es passiert )
    SLX->ERGEBNIS SWAP DROP
    ELSE 2DROP DROP END_IF
  ;
: B+0 ( a b --> a+0 b+0 )
  SWAP A+0 SWAP A+0 ;
</sekt>



<sekt inhalt="Anwenden in / MOD GGT BK...">
: / ( b d --> q )
  NEBENRECHNUNG ROT ROT 
  /MOD SWAP DROP
  SWAP HAUPTRECHNUNG A+0
  ;
: MOD ( b d --> r ) 
  NEBENRECHNUNG ROT ROT 
  /MOD DROP 
  SWAP HAUPTRECHNUNG A+0
  ;

: GGT ( a b --> ggt )
  NEBENRECHNUNG ROT ROT
  BEGIN DUP WHILE
    SWAP OVER MOD REPEAT DROP 
  SWAP HAUPTRECHNUNG A+0 ;
: BK ( a b --> a/ggt b/ggt ) 
  NEBENRECHNUNG ROT ROT
  2DUP GGT ROT OVER / ROT ROT / 
  ROT HAUPTRECHNUNG B+0 ;



777 99 BK B.




( je einmal * und + in NNUMBER )
: NNUMBER ( baddr n --> a faddr )
  NEBENRECHNUNG ROT ROT
  7 LOCAL ( L3 L4 nicht verwendet
  L1 ! L0 !
  0 L1 @ IF
    DUP L2 ! 1 L5 ! ( Vorzeichen )
    BEGIN ( M23 Vorzeichen gucken )
      -1 L6 ! 
      L0 @ L2 @ M+ C@
      2B ( 43 2B ) = IF L2 @ 1+ L2 ! 0 L6 ! ELSE
        L0 @ L2 @ M+ C@
        2D ( 45 2D ) = IF L2 @ 1+ L2 !
          0 L6 !
          L5 @ MINUS L5 ! END_IF
        END_IF
      L6 @ UNTIL
    L2 @ L1 @ LT IF
      BEGIN
        L0 @ L2 @ M+ C@
        DUP IF ( oo L1 auf Bytes )
          DIGIT NOT IF DROP L1 @ MINUS L1 ! ELSE
            SWAP BASE @ * +
            L2 @ 1+ L2 ! 
            END_IF
          ELSE DROP L2 @ L1 ! END_IF
        L2 @ L1 @ LT NOT UNTIL
      END_IF ( M19 )
    END_IF ( M19 )
  L5 @ 0LT IF MINUS END_IF
  L2 @ L1 @ M- ( oo noch kein fadr !!!!!!!!!!!! siehe NNUMBER )
  DUP IF DROP L0 @ L2 @ M+ END_IF ( jetzt faddr )
  END_LOCAL
  ROT HAUPTRECHNUNG SWAP A+0 SWAP
  ;

22 WORD: N" ( /number/  --> n ) NNUMBER DROP ;



( REPLACE: NUMBER NNUMBER ;

N" 111111111111111" DUP * DUP . DUP M.
N" 111111111111111" DUP . DUP M.
/MOD OVER M. DUP M. B.

N" 0026D4346A00" DUP .
N" 00000FC82800" DUP .
2DUP /MOD B.
2DUP BK B. 
( richtig wäre D6A2200 275 bei /MOD )
( richtig wäre 3135 14 bei BK )

N" 00A7426290A8C945E959A780" DUP .
N" 000002330657FDD698" DUP .
/MOD B. 
( richtig wäre 158B5843D5ED0 4C0CF598D2 )
( und nicht   0325AF2C3F8838 4C0CF598D3 )

( als vorlaeufigen Abschluss nochmal )
" 111111111111111" NNUMBER DROP DUP * .

N" 000002330657FDD698" N" 4C0CF598D3" * .
N" 000002330657FDD698" N" 4C0CF598D2" * .




: ^ ( a n --> a^n )
  NEBENRECHNUNG ROT ROT ( erg a n )
  4 LOCAL
  DUP 0LT IF 12 ERROR END_IF    
  2           ( a n 2 )        
  L3 ! L2 ! L1 !    (  R1-3: a  n  2 )
  1           ( p=1          a  n  2 )
  BEGIN       ( p            a  n  2 )
    L2 @ L3 @ ( p n 2        a  n  2 )
    M/MOD     ( p r n/2      a  n  2 )
    L2 !      ( p r          a n/2 2 )
    IF        ( p            a n/2 2 )
      L1 @    ( p a          a n/2 2 )
      *      ( p*a          a n/2 2 )
      END_IF  ( p*a          a n/2 2 )
    L2 @      ( p*a n/2      a n/2 2 )
    WHILE     ( p*a          a n/2 2 )
      L1 @    ( p*a a        a n/2 2 )
      L1 @    ( p*a a a      a n/2 2 )
      *      ( p*a a*a      a n/2 2 )
      L1 !    ( p*a        a*a n/2 2 )
      REPEAT  ( p*a        a*a n/2 2 )
  END_LOCAL   ( a^n )
  SWAP HAUPTRECHNUNG A+0
  ;           ( a^n )


3333 2 ^ 10 * .
1111 2 ^ .


10 20 ^ 10 10 ^ DUP -1 + SWAP 1 + * - .
</sekt>

<sekt inhalt="nochmal . für beliebige Zahlenbasis">
: . ( a -->  /zahl/ )
  BASE @ 10 = IF . ELSE
    NEBENRECHNUNG SWAP
    DUP 0LT IF MINUS ." -" END_IF
    DUP 0= IF ." 0 " DROP ELSE
      -1 SWAP ( Stapelmarkierung )
      BEGIN DUP WHILE BASE @ /MOD REPEAT DROP
      BEGIN DUP 0LT NOT WHILE 30 M+ DUP 39 > IF 7 M+ END_IF EMIT REPEAT
      20 EMIT DROP END_IF
    HAUPTRECHNUNG
    END_IF
  ;
: B. SWAP . . ;

777 99 BK B.
INIT
</sekt>

<sekt inhalt="Array-Objekte">
: ZERLEG ( a --> adr i )
  3FFF AND DUP 1+ SWAP @ ;

N" 111111111111111" DUP * DUP .
DUP ZERLEG SWAP M. M.

: OBJ? ( a --> flag )
  ABS DUP 04 000 MLIT LT IF DROP 0 ELSE
    ZERLEG SWAP DROP 04 000 MLIT LT IF 0 ELSE -1 
      END_IF END_IF
  ;

: L ( a i -> b ) OVER OBJ? IF
    SWAP ZERLEG 3FFF AND ( i adr j )
    ROT 2DUP ( adr j i j i )
    > IF SWAP DROP M+ @ ELSE 2DROP DROP 0 END_IF
    ELSE IF DROP 0 END_IF END_IF ;

: G ( a i -> a i b ) 2DUP L ;

: H ( a i b --> a' )
  DUP >R
  ROT ROT ( b a i )
  OVER OBJ? 0= OVER 0= AND R> OBJ? 0= AND IF 2DROP ELSE
    OVER OBJ? 0= IF 
      DUP 1+ SPEICHERHOL ( b a i addrneu )
      ROT OVER ! ( b i addrneu )
(      OVER 1+ OVER 1- ! ( b i addrneu ( aha, macht schon SPEICHERHOL )
      04 000 MLIT OVER 1- +! ( das ist jetzt neu fuer OBJ? )
      DUP >R M+ ! R> ( addrneu )
      1- 04 000 MLIT OR
      ELSE
        OVER                 ( b a i a )
        ZERLEG 3FFF AND      ( b a i addr j )
        ROT                  ( b a addr j i )
        2DUP > IF SWAP DROP ROT >R M+ ! R> ELSE
          DUP 1+ SPEICHERHOL ( b a addr j i addrneu )
          SWAP >R DUP >R     ( b a addr j addrneu      addrneu i )
          SWAP MOVE DROP R>  ( b addrneu            i )
(          R 1+ OVER 1- !    ( b addrneu                i )
          04 000 MLIT OVER 1- @ OR OVER 1- !   ( das ist jetzt neu fuer OBJ? )
          SWAP OVER R> M+ !  ( addrneu )
          1- 04 000 MLIT OR  ( a' )
          END_IF
        ZERLEG 3FFF AND      ( adr l )
        BEGIN 2DUP M+ 1- @ 0= OVER 1 > AND WHILE 1- REPEAT ( adr lneu )
        OVER @ OBJ? 0= OVER 1 = AND IF DROP @ ELSE
          SWAP 1- SWAP       ( addr-1 lneu )
          04 000 MLIT OR OVER ! 04 000 MLIT OR
          END_IF  
        END_IF
    END_IF
  ;
  
: . ( obj --> )
  DUP OBJ? IF
    ." [ "
    ZERLEG 3FFF AND OVER M+ SWAP ( eadr+1 aadr )
    BEGIN 2DUP > WHILE DUP @ RECURSE 1+ REPEAT 2DROP
     ." ] "
    ELSE . END_IF
  ;
: B. SWAP . . ;

7 DUP .
2 9 H DUP .
3 11 H DUP .
1 4 1 6 H H DUP .
1 G 2 88 H H DUP . 
1 G 2 0 H H DUP .
0 G 2 1987 H H DUP .
1 0 H DUP .
3 0 H DUP .
2 0 H DUP .
2 2444 H DUP .
0 N" 7777777" H DUP .
2 0 H DUP .


0
0 0 0 1 H 1 2 H 2 5 H H DUP .
1 0 0 3 H 1 4 H 2 8 H H DUP .
2 0 0 9 H 1 2 H 2 1 H H CR DUP .

0 1 4 H DUP .
0 0 0 1 4 H H .

0 
0 0 0 60 H 1 30 H 2 20 H H DUP .
1 0 0 30 H 1 20 H 2 15 H H DUP .
2 0 0 20 H 1 15 H 2 12 H H CR DUP .

0 VARIABLE SPMERK
: [ ( ---> spmerk )
  SPMERK @ SP @ SPMERK !
  ;

: ] ( spmerk a b c d ... z --> matrix )
  0 BEGIN SP @ 1- SPMERK @ M- WHILE
    SP @ 2 M- SPMERK @ M- ROT H REPEAT
  SWAP SPMERK !
  ;
</sekt>

<sekt inhalt="Matrix invertieren">
: OBJ+0 ( obj --> obj+0 )
  DUP OBJ? IF DUP >R
    ZERLEG 3FFF AND          ( adr n )
    SWAP OVER M+ 1- SWAP     ( eadr-1 n )
      BEGIN DUP WHILE SWAP   ( n eadr-1 )
        DUP @ RECURSE OVER ! ( n eadr-1 )
        1- SWAP 1-           ( eadr-1 n-1 )
        REPEAT               ( adr-1 0 )
    2DROP R>                 ( obj )
    ELSE A+0 END_IF
  ;

[ 12 18 1B ] OBJ+0 .

: OBJDUMP ( obj --> )
  DUP OBJ? IF
    ZERLEG 3FFF AND                ( adr n )
      BEGIN DUP WHILE SWAP         ( n adr )
        CR OVER M. DUP M. DUP @ 
        DUP M. DUP ABS 3FFF > NOT IF -1 M. -1 M. ELSE DUP ABS ZERLEG M. M. END_IF
        DUP . RECURSE             ( n adr )
        1+ SWAP 1-                 ( adr+1 n-1 )
        REPEAT                     ( adr+n 0 )
    2DROP                          ( )
    ELSE DROP END_IF
  ;

[ 12 18 1B ] OBJDUMP
[ [ 12 18 1B ] [ 1E 21 24 ] ] OBJDUMP

: INVERTIEREN ( matrix dim --> invmat nenner ) <h href="INVERTIEREN.xml" />
  ( L0=nr L1=N L2=i L3=j L4=k L5=Y L6=Z L7=alternenner )
  8 LOCAL NEBENRECHNUNG L0 !
  L1 ! 1 ( mat nenner )
  L1 @ L2 ! BEGIN -1 L2 +! ( CR L2 M? ERGEBNIS M?
    L7 ! ( mat ) 0 L5 ! 0 L6 !
    DUP L2 @ L L2 @ L ( mat neuernenner )
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L L2 @ L L5 @ L3 @ ROT H L5 !
      OVER L2 @ L L3 @ L L6 @ L3 @ ROT H L6 !
      L3 @ 0= UNTIL
    L5 @ L2 @ L L7 @ + L5 @ L2 @ ROT H L5 !
    L6 @ L2 @ L L7 @ - L6 @ L2 @ ROT H L6 !
    L1 @ L3 ! BEGIN -1 L3 +!
      OVER L3 @ L ( mat nenner mat[L3] )
      L1 @ L4 ! BEGIN -1 L4 +! ( CR L3 M? L4 M? ERGEBNIS M?
        NEBENRECHNUNG ROT ROT SWAP ( mat erg mat[L3] nenner )
        OVER L4 @ L OVER *
        L5 @ L3 @ L L6 @ L4 @ L * -
        L7 @ / ( mat erg mat[L3] nenner bijneu )
        2SWAP SWAP ( mat nenner bijneu mat[L3] erg )
        HAUPTRECHNUNG SWAP A+0 ( mat nenner mat[L3] bijneu+0 )
        SWAP L4 @ ROT H ( mat nenner mat[L3]neu )
        L4 @ 0= UNTIL
      ROT L3 @ ROT H SWAP ( matneu nenner )
      L3 @ 0= UNTIL
    A+0 ( verschiebt nenner hinter matneu )
    ( RECHENBLOCK )
    ( CR ." vor 1. OBJ+0 " ERGEBNIS M? ( OVER OBJDUMP DUP . DUP ABS M.
    L0 @ HAUPTRECHNUNG SWAP OBJ+0 SWAP A+0
    ( ." nach 1. OBJ+0 " ERGEBNIS M? ( OVER OBJDUMP DUP . DUP ABS M.
    L2 @ 0= UNTIL
  END_LOCAL
  ;

( so und jetzt anwenden )

[ [ 3C 1E 14 ] ( dezimal 60 30 20 )
  [ 1E 14 0F ] ( dezimal 30 20 15 )
  [ 14 0F 0C ] ( dezimal 20 15 12 )
  ] 3
OVER . DUP M.
INVERTIEREN
OVER . DUP .
( herauskommen muss dabei )
(             [ [ F -3C 32 ] [ -3C 140 -12C ] [ 32 -12C 12C ] ] 64 )
( dezimal        15 -60 ...                                      100 )


( paar Vandermonde-Matrizen invertieren: )
INIT
[ [ 1 1 1 1 ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ ]
  ]
4 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 480 -360 180 -48 ] [ -4E0 558 -2A0 84 ] ... ] 120 )

INIT
[ [ 1 1 1 1 1 ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ 2 5 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ 3 5 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ 4 5 ^ ]
  [ 5 1 ^ 5 2 ^ 5 3 ^ 5 4 ^ 5 5 ^ ]
  ]
5 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll  [ [ 2A300 -2A300 ... ] ] 8700 )

: VANDERMONDEMATRIX ( n --> mat )
  3 LOCAL
  L0 !
  0 
  L0 @ L1 ! BEGIN L1 @ DUP WHILE 1- L1 !
    L1 @ G
    L0 @ L2 ! BEGIN L2 @ DUP WHILE 1- L2 !
      L2 @ L1 @ 1+ L2 @ 1+ ^ 
      H
      REPEAT DROP
    H
    REPEAT DROP
  END_LOCAL
  ;

( 4 VANDERMONDEMATRIX DUP .

INIT
4 VANDERMONDEMATRIX
4 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 480 -360 180 -48 ] [ -4E0 558 -2A0 84 ] [ 1B0 -240 150 -48 ] [ -30 48 -30 C ] ] 120
( gekürzt [ [ 60 -48 20 -6 ] [ -68 72 -38 B ] [ 24 -30 1C -6 ] [ -4 6 -4 1 ] ] 18 ok

INIT
5 VANDERMONDEMATRIX
5 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 2A300 -2A300 1C200 -A8C0 1B00 ] [ -36240 4B3C0 -36D80 15720 -3840 ] [ 18F60 -297C0 22740 -E6A0 2760 ] [ -4EC0 9240 -8700 3DE0 -B40 ] [ 5A0 -B40 B40 -5A0 120 ] ] 8700
( gekürzt [ [ 258 -258 190 -96 18 ] [ -302 42E -30C 131 -32 ] ... [ 5 -A A -5 1 ] ] 78 ok

INIT
6 VANDERMONDEMATRIX
6 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 8E62000 -B1FA800 9E34000 ... -32A00 8700 ] ] 17BB000
( gekürzt [ [ -10E0 1518 -12C0 A8C -360 78 ] ... [ 6 -F 14 -F 6 -1 ] ] -2D0 ok

INIT
7 VANDERMONDEMATRIX
ERGEBNIS M?
7 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ CC65AF0000 -13298868000 ... 17BB000 ] ] 1D33190000 
( gekürzt [ [ -89D0 CEB8 -E5B0 AC44 -52B0 16F8 -2D0 ]  ... [ -7 15 -23 23 -15 7 -1 ] ] -13B0 ok

INIT
8 VANDERMONDEMATRIX
ERGEBNIS M?
8 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 8FB77F0C000000 -FB811E55000000 ... 1D33190000 ] ] 11F6EFE1800000
( gekürzt [ [ 4EC00 -89D00 B7C00 -AC440 6E400 -2DF00 B400 -13B0 ] ... [ -( 1C -38 46 -38 1C -8 1 ] ] 9D80 ok

INIT
9 VANDERMONDEMATRIX
ERGEBNIS M?
9 INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ 37F3F5B381040000000 ... 11F6EFE1800000 ] ] 6378D13F1E40000000
( gekürzt [ [ 31D580 -63AB00 9B0A00 -AE6B40 8B8900 -4D8500 1C7A00 -63AB0 9D80 ] ... [ 9 -24 54 -7E 7E -54 24 -9 1 ] ] 58980 ok

INIT
0A VANDERMONDEMATRIX
ERGEBNIS M?
0A INVERTIEREN
OVER . DUP .
ERGEBNIS M?
( herauskommen soll [ [ D726B3E61B37C18000000000 ... 6378D13F1E40000000 ] ] 1583DECA35EBF9C000000000
( gekürzt [ [ -229B600 4DDD980 -8A6D800 B5AFB80 ... -D2 78 -2D A -1 ] ] -375F00 ok

INIT
0B VANDERMONDEMATRIX
ERGEBNIS M?
( 0B INVERTIEREN OVER . DUP . ERGEBNIS M?
( herauskommen soll [ [ 2331530F3797CA8619C400000000000 -57FB4FA60AFB7A4F406A00000000000 ... 1583DECA35EBF9C000000000 ] ] 333078D050DCC97D3CC00000000000
( gekürzt [ [ -1A2BE700 416DC180 -82DB8300 ... -14A A5 -37 B -1 ] ] -2611500 ok

INIT
0C VANDERMONDEMATRIX
ERGEBNIS M?
( 0C INVERTIEREN OVER . DUP . ERGEBNIS M?
( herauskommen soll 
( OVER . DUP . [ [ 1569BD000 -3AE2C7C00 82DB83000 ... -318 1EF -DC 42 -C 1 ] ] 1C8CFC00 ok

( mehr geht erstmal nicht weil nicht mehr Platz )


INIT
[ [ 112  431  199 764 987 434 ]
  [ 543 45 33 41 789 566 ]
  [ 543 145 33 42 789 566 ]
  [ 875 687 098 675 677 574 ]
  [ 875 66B 0987 675 678 634 ]
  [ 454 33 555 934 655 633 ]
  ] 
DUP .
6 INVERTIEREN ( mat dim --> invmat nenner )
OVER .
DUP .
</sekt>

<sekt inhalt="Reste die auch weggelassen werden können, wenn alles geht">
: VLIST
  LFA @ BEGIN 
    DUP 1+ @ OVER 2 M+ @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ M+ REPEAT
  DROP ;

: WLIST
  LFA @ BEGIN ( CR ) DUP M.
    DUP 1+ @ OVER 2 M+ @ TYPE 20 EMIT 
    DUP @ WHILE DUP @ M+ REPEAT
  DROP
  ;

: REPLACE: ( /name/ ) 
  CSP! ( oo )
  20 WORD FIND DUP IF 
    LCFA DROP 1+ ( pfa
(    HERE OVER M- 1- JRBIT XSETBT SWAP !
    HERE SWAP DP ! DUP COMPILE, RETURN , DP !
    1 STAT !
    ELSE 2DROP 3 ERROR END_IF ;

: FORGET ( /name/ )
  20 WORD FIND IF 
    DP !
    HERE DUP @ M+ LFA !
    HERE 1+ @ BZEIG !
    ELSE DROP ." nicht gefunden " END_IF
  ;

: FEHLERTEXT ( n --> n )
  CR
  DUP 0 = IF ." Division durch Null" END_IF
  DUP 3 = IF ." Wort nicht definiert" END_IF
  DUP 6 = IF ." Eingabezeile zu lang" END_IF
  DUP 9 = IF ." Strukturfehler in IF END_IF BEGIN UNTIL DO LOOP " END_IF
  DUP 12 = IF ." negativer Exponent" END_IF
  DUP 369 = IF ." Zahlenspeicher voll" END_IF
  DUP 1234 = IF ." große ganze Zahlen kompilieren geht momentan nicht." END_IF
  ;

( ganz neu: Steuerungstasten: ^A bis ^G, weiter ^H=^A ^L=^B ... )
2F18 8 0 FILL
: STRG: : HERE 3 M- DUP M. @ 1+ DUP M. @ DUP M. 40 M- HERE SWAP 7 AND 2F18 M+ ! ;
STRG: ^G 7 EMIT ." /1xPIEP/" ;
STRG: ^F 7 EMIT ." QUIT" QUIT ;
STRG: ^A ." Angehalten für genau eine Eingabezeile: "
  CR FA00 100 EXPECT INTERPRET ." ok";

: QUERY ( adr --> n ) TIB @ 100 EXPECT ;

IMMEDIATE: (*REM*) 
  3C EMIT ." /ok>"
  BEGIN CR QUERY " (*END*)" Z= UNTIL
  3C EMIT ." ok>"
  ;
</sekt>

<sekt inhalt="Reste, die schon weggelassen sind">
(*REM*)
  RAMP1 VARIABLE RAMP3 ( RAMP3 TIB RAMP1
: RAMBUF ( /name/  n --> )
  MINUS RAMP3 +! RAMP3 @ CONSTANT ; ( oo INDVAR muss da her )

( - LOOP's - sind aber sehr langsam )
: I RP @ 1+ @ ;
: J RP @ 3 M+ @ ;
: K RP @ 5 M+ @ ;
: (DO) SWAP R> ROT ROT >R >R >R ;
: (LOOP) R> R> 1+ DUP R LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R ;
: (+LOOP) R> R>  ROT DUP  0LT IF M+ R OVER
  ELSE M+ DUP R END_IF LT IF >R 0 
  ELSE R> DROP DROP -1 END_IF SWAP >R  ;
IMMEDIATE: DO COMPILE (DO) HERE ;
IMMEDIATE: LOOP COMPILE (LOOP) 0BRANCH, ;
IMMEDIATE: +LOOP COMPILE (+LOOP) 0BRANCH, ;
( : LL 0 DO I M. LOOP ; 7 LL ( ok geht )


IMMEDIATE: () 0 WORD 2DROP ;
: B. ( a b --> ) SWAP M. M. ;
: 2@ ( adr --> a b )
  DUP 1+ @ SWAP @ ;
: 2! ( a b adr --> )
  SWAP OVER ! 1+ ! ;
: 2? 2@ B. ;

: LDUMP LFA @ HERE OVER M- DUMP ;

A012 MCODE D+
A013 MCODE D-


( - paar Geraeteadressen: )
D004 CONSTANT UHR
D005 CONSTANT SWTI
D00D CONSTANT UHRL
2D05 CONSTANT XOFFINPUT

( - "Platinen befestigen und entfernen" )
20 RAMBUF TLISTE
TLISTE VARIABLE TLISTENZEIGER
: TLISTY 
  TLISTENZEIGER @ TLISTE BEGIN 
    DUP @ CR DUP M. 3 M- 2@ SWAP TYPE 
    1+ 2DUP = UNTIL 2DROP ;

0 VARIABLE REMOPFA
0 VARIABLE STATMERK
0 VARIABLE EXXIUHR
: EXXI
  UHRL @ >R
  STAT @ STATMERK ! 0 STAT ! ( eigentlich >R )
  TLISTE
  BEGIN DUP TLISTENZEIGER @ LT WHILE
    DUP >R @ EXECUTE R> 1+ REPEAT DROP
  STATMERK @ STAT ! 
  UHRL @ R> M- EXXIUHR ! 
  ;
( ' EXXI 6 1+ M- 6000 OR 6 !
' EXXI 4000 M+ 16 ! ( CR geht momentan +F9XX )

: ENTFERNE 
  20 WORD FIND LCFA DROP 1+
  ( DUP 0= IF 3 ERROR END_IF )
  0 REMOPFA !
  TLISTENZEIGER @ TLISTE > IF
    TLISTENZEIGER @ TLISTE DO
      DUP I @ = IF
        1 REMOPFA !
        -1 TLISTENZEIGER +!
        END_IF
      REMOPFA @ IF
        I 1+ @ I !
        END_IF
      LOOP END_IF
  REMOPFA !
  ;
  
: BEFESTIGE ENTFERNE
  REMOPFA @ TLISTENZEIGER @ !
  1 TLISTENZEIGER +! 
  ;


: DABS ( h l --> h' l' )
  OVER 0LT IF 0 0 2SWAP D- END_IF ;


( CASEOFS aus'm PSION: )
: CASEOFS ( n  /name/ --> )
  DUP RAMBUF
  0 DO
    0 I RAMP3 @ + !
    LOOP
  ;

: CASEOF: ( fn en --> )
  M+ HERE DPMERK @ M- SWAP !
  CSP! 1 STAT !
  ;

: CASEOF ( fn en --> )
  M+ @ DUP IF
    DPMERK @ M+ EXECUTE
    ELSE DROP END_IF ;

( - CASE )
( : BIT ( i n --> bit )
(   2 ROT DUP 0LT IF 99 ERROR ELSE 
(   ^ AND 0= 1+ END_IF ; 

: (OF) ( n r i --> f r' )
  ROT = DUP ROT OR ;
: (RANGE-OF) ( n1 n2 r i --> f r' )
  DUP >R ROT > ROT R> > OR 0= DUP ROT OR ;
( : (BIT-OF) ( n r i --> f r' )
(   ROT BIT DUP ROT OR ;

IMMEDIATE: CASE ( n --> )
  " >R 0 >R" 
  INTERPRET ;
IMMEDIATE: END_CASE ( --> )
  " R> R> 2DROP" 
  INTERPRET ;
IMMEDIATE: OF ( n --> )
  " R> R (OF) >R IF" 
  INTERPRET ;              
IMMEDIATE: RANGE-OF ( n1 n2 --> )
  " R> R (RANGE-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: BIT-OF ( m --> )
  " R> R (BIT-OF) >R IF" 
  INTERPRET ;
IMMEDIATE: ELSEOF ( --> )
  " R 0= IF" INTERPRET ;
IMMEDIATE: END_OF ( --> )
  " END_IF" INTERPRET ;
: ERR ." keine gültige RAM-Adresse" QUIT ;
' ERR 4000 OR 22 !
' ERR 4000 OR 20 !

IMMEDIATE: /; 0 STAT ! CSP? HERE 1- @ 800 OR HERE 1- ! SMUDGE [ SMUDGE ] ; 
( : T 77 88 DROP /; 
( ' T 8 DUMP
( : W PAUSENBIT ! /;
( ' W 8 DUMP


( Ausgabe von ESCAPE-Sequenzen: sie vertragen sich aber nicht mit xml, besser CSI nehmen )
20 WORD: ESC 1B EMIT BEGIN OVER C@ EMIT SWAP 1+ SWAP 1- DUP 0= UNTIL DROP ;
ESC ]0;FORTY-FORTH 07 EMIT ( 07 EMIT schließt ]
: FESTPOSITION ESC [s ESC [1;1H ESC [31m ; ( saveC Pos1,1 redcolor
: RUCKPOSITION ESC [u ESC [39m ; ( restoreC defaultcolor

( Alternativer Start mit ESCAPE-Sequenzen )

: QUIT2 
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ESC [34m ." ok" END_IF CR ESC [39m 
    TIB @ 100 EXPECT ESC [36m INTERPRET 
    AGAIN ;

( REPLACE: QUIT QUIT2 ;
( QUIT

: QUIT3
  RP0 @ RP !
  BEGIN 
    STAT @ 0= IF ."   " END_IF
    CR  
    CRBIT @ 2 AND IF 3C EMIT ." /ok>" END_IF
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 36 EMIT 6D EMIT END_IF
    TIB @ 100 EXPECT 
    CRBIT @ 4 AND IF C2 EMIT 9B EMIT 33 EMIT 39 EMIT 6D EMIT END_IF
    CRBIT @ 2 AND IF 3C EMIT ." ok>" END_IF
    INTERPRET
    AGAIN ;


: IOSTART
  2C40 2C00 DO I @ I ! LOOP
  2D30 2D14 DO I @ I ! LOOP
  ;
IOSTART

( wozu das RBIT war? für relatives CR )
: COMPILE, ( adr --> )
  RBIT @ IF 4000 ELSE 
    DP @ 1+ M- 0FFF AND 3000 END_IF
    0000 M+ M+ , ;

: a*a;; 
  A 2000 111111 FILL
  B 2000 111111 FILL
  C 4001 000000 FILL
  0 2000 A 0 2000 B C SMUL 7 EMIT ;
(*END*)
</sekt>

<sekt inhalt="DEMO">
56 89 M* M.
77 88 M+ M.

( aktuelles Vokabular

VLIST

( nochmal mit Speicheradressen, vor jedem Wort steht dessen "Linkfeld"_Adresse=Aufruf_Adresse-4 )

WLIST

( LED's zum Leuchten bringen, also auf Adresse 2D04 ausgeben )

2D04 CONSTANT LEDS
55 LEDS !

( erreichte Programmdresse in 0000-1FFF )

HERE M.

( erreichte Adresse in Textspeicher E000-FFFF )

BZEIG M?

( aktuelle Stapelhoehe )

SP M?

( Ein neues Wort definieren )

: H ." Hallo Welt " ;

H

( Bedingung IF )

: W ( n --> ) 
  ." Das ist eine " 
  1 AND IF ." un" END_IF 
  ." gerade Zahl " ; 

7 W
8 W

( Programmschleifen, die für DO LOOP ist aber momentan stillgelegt. )

( : X ( n --> )
(   0 DO I M. LOOP ;
( 13 X 

( oder )

: Y ( n --> )
  0 BEGIN DUP M. 1+ 2DUP = UNTIL 2DROP ;

13 Y

( oder )

: Z ( n --> )
  0 BEGIN 2DUP > WHILE DUP M. 1+ REPEAT 2DROP ;

13 Z

( alles ab LEDS wieder vergessen )

HERE M. BZEIG M?
FORGET LEDS
HERE M. BZEIG M?









( Also an der Stelle nach FFINIT1SMUL.TXT hab ich jetzt )
( N" ( /number/  -> n        liest bis " eine grosse ganze Zahl ein
(                            kleine ganze Zahlen wie bisher eingeben
( + - * / /MOD MOD ^  und rechnet damit
( .   a -->                 und gibt sie aus
( BK  a b --> a' b'         Kürzen
( GGT a b --> ggt           groesster gemeinsamer Teiler
( 
( also direkt eingeben und mit + - * / rechnen geht hier noch nicht


( ERGEBNIS ist unpassend gewählter Variablenname, 
( bezeichnet ab welcher Adresse das nächste Ergebnis gespeichert wird,
( Platz dafür ist von 1400H bis 1FFFH, aktuell erreicht: )
 
ERGEBNIS M? ( Zahlenspeicher gefuellt bis ) 

ZAHLENSPEICHER @ ERGEBNIS ! ( Zahlenspeicher leeren )

ERGEBNIS M?

N" 111111111111111" DUP * .

ERGEBNIS M?

( dritte binomische Formel 10^20-{10^10+1}*{10^10-1}=1 )
10 20 ^ 10 10 ^ 1 - 10 10 ^ 1 + * - .

ERGEBNIS M?


( Zahlenbasis wechseln )

: HEX 10 BASE ! ;
: DECIMAL 0A BASE ! ;

HEX N" 10000"
DECIMAL DUP .
HEX DUP .

HEX N" 100000000"
DECIMAL DUP .
HEX DUP .
</sekt>

<sekt inhalt="Multiproc.">
REPLACE: NUMBER NNUMBER ; ( kann auch weiter hoch...
: ? @ . ;

( EXXI reaktivieren, muss dann aus den "nicht mehr verwendeten" noch raus...
: 2@ ( adr --> a b )
  DUP 1+ @ SWAP @ ;
: 2! ( a b adr --> )
  SWAP OVER ! 1+ ! ;
: 2? 2@ B. ;

XBIT VARIABLE RAMP3 ( RAMP3 TIB RAMP1
: RAMBUF ( /name/  n --> )
  MINUS RAMP3 +! RAMP3 @ CONSTANT ; ( oo INDVAR muss da her )

20 RAMBUF TLISTE
TLISTE VARIABLE TLISTENZEIGER
: TLISTY 
  TLISTE BEGIN TLISTENZEIGER @ OVER > WHILE 
    DUP @ CR DUP M. 3 M- 2@ SWAP TYPE 
    1+ REPEAT DROP ;

0 VARIABLE REMOPFA
0 VARIABLE STATMERK
0 VARIABLE EXXIUHR
: EXXI
  ( UHRL @ >R
  STAT @ STATMERK ! 0 STAT ! ( eigentlich >R )
  TLISTE
  BEGIN DUP TLISTENZEIGER @ LT WHILE
    DUP >R @ EXECUTE R> 1+ REPEAT DROP
  STATMERK @ STAT ! 
  ( UHRL @ R> M- EXXIUHR ! 
  ;

( EXXI in KEY einbauen
04 ' EXXI MLIT ' KEY ! ( KEY war vorher : KEY BEGIN NOOP ... REPEAT ;

: ENTFERNE 
  20 WORD FIND LCFA DROP 1+
  ( DUP 0= IF 3 ERROR END_IF )
  0 REMOPFA !
  TLISTE BEGIN TLISTENZEIGER @ OVER > WHILE
    2DUP @ = IF
      1 REMOPFA !
      -1 TLISTENZEIGER +!
      END_IF
    REMOPFA @ IF
      DUP 1+ @ OVER !
      END_IF
    1+ REPEAT DROP
  REMOPFA !
  ;
  
: BEFESTIGE ENTFERNE
  REMOPFA @ TLISTENZEIGER @ !
  1 TLISTENZEIGER +! 
  ;

( zum Ausprobieren:
( 0 VARIABLE EMAIL_DA
( : ZUCK EMAIL_DA @ 2D04 ! ;
(
( BEFESTIGE ZUCK TLISTY
( -1 EMAIL_DA !
( 0 EMAIL_DA !
( ENTFERNE ZUCK


1800 ERGEBNIS !


( jetzt los mit LINKS-RECHTS-OBEN-UNTEN
2804 CONSTANT LINKS-ABGESCHICKT
2804 CONSTANT RECHTS-ABGESCHICKT
2805 CONSTANT LINKS-ANGEKOMMEN
2805 CONSTANT RECHTS-ANGEKOMMEN
2806 CONSTANT OBEN-ABGESCHICKT
2806 CONSTANT UNTEN-ABGESCHICKT
2807 CONSTANT OBEN-ANGEKOMMEN
2807 CONSTANT UNTEN-ANGEKOMMEN
2000 CONSTANT RECHTS-BYTES
2400 CONSTANT UNTEN-BYTES
2000 CONSTANT LINKS-BYTES
2400 CONSTANT OBEN-BYTES
-1 VARIABLE IAM1X
-1 VARIABLE IAM1Y	
-1 VARIABLE IAM2X
-1 VARIABLE IAM2Y
0 VARIABLE LINKS-MERK
0 VARIABLE OBEN-MERK
0 VARIABLE RECHTS-MERK
0 VARIABLE UNTEN-MERK

: R-ABSCHICKEN ( x y n op --> )
  2OVER >R >R
  BEGIN RECHTS-ANGEKOMMEN @ RECHTS-MERK @ = UNTIL
  RECHTS-BYTES
  SWAP OVER ! 1+ SWAP >R SWAP >R
  SWAP OVER ! 1+ R> OVER ! 1+ R> SWAP !
  RECHTS-ANGEKOMMEN @ NOT 1 AND RECHTS-MERK !
  RECHTS-ANGEKOMMEN @ NOT RECHTS-ABGESCHICKT !
  CR R> . R> . ." r-abgeschickt"
  ;
: U-ABSCHICKEN ( x y n op --> )
  2OVER >R >R
  BEGIN UNTEN-ANGEKOMMEN @ UNTEN-MERK @ = UNTIL
  UNTEN-BYTES
  SWAP OVER ! 1+ SWAP >R SWAP >R
  SWAP OVER ! 1+ R> OVER ! 1+ R> SWAP !
  UNTEN-ANGEKOMMEN @ NOT 1 AND UNTEN-MERK !
  UNTEN-ANGEKOMMEN @ NOT UNTEN-ABGESCHICKT !
  CR R> . R> . ." u-abgeschickt"
  ;

( 1 2 0 0 R-ABSCHICKEN
( RECHTS-BYTES 8 DUMP RECHTS-ABGESCHICKT ? RECHTS-ANGEKOMMEN ?
( RECHTS-ANGEKOMMEN @ RECHTS-ABGESCHICKT !
( 5 6 1 9 U-ABSCHICKEN
( UNTEN-BYTES 8 DUMP UNTEN-ABGESCHICKT ? UNTEN-ANGEKOMMEN ?
( UNTEN-ANGEKOMMEN @ UNTEN-ABGESCHICKT !

: XY-PROC ( x y --> )
  CR ." XY " OVER . DUP .
  OVER IAM2X @ LT OVER IAM2Y @ LT AND IF -1 IAM1X ! -1 IAM1Y ! -1 IAM2X ! -1 IAM2Y ! END_IF
  OVER IAM1X @ = NOT IAM2X @ -1 = AND IF 
    IAM1X @ -1 = IF OVER IAM1X ! ELSE OVER IAM2X ! END_IF
    CR IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
    OVER 1+ OVER 0 0 U-ABSCHICKEN
    END_IF
  DUP IAM1Y @ = NOT IAM2Y @ -1 = AND IF 
    IAM1Y @ -1 = IF DUP IAM1Y ! ELSE DUP IAM2Y ! END_IF
    CR IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
    OVER OVER 1+ 0 0 R-ABSCHICKEN
    END_IF
  2DROP ;

( -1 IAM1X ! -1 IAM1Y ! -1 IAM2X ! -1 IAM2Y ! 
( IAM1X ? IAM1Y ? IAM2X ? IAM2Y ? 
( OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 5 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 5 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 3 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 3 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 5 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 5 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 3 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0 3 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( 0A 0 XY-PROC OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !


( empfangene Bytes jetzt auswerten
( ENTFERNE L-AUSLES
( ENTFERNE O-AUSLES

: L-AUSLES
  LINKS-MERK @ LINKS-ABGESCHICKT @ = NOT IF
    LINKS-BYTES @ 0= IF 
      LINKS-BYTES 1+ DUP @ SWAP 1+ @ 
      LINKS-ABGESCHICKT @ LINKS-MERK !
      LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
      XY-PROC END_IF
    END_IF
  ;

: O-AUSLES
  OBEN-MERK @ OBEN-ABGESCHICKT @ = NOT IF
    OBEN-BYTES @ 0= IF 
      OBEN-BYTES 1+ DUP @ SWAP 1+ @ 
      OBEN-ABGESCHICKT @ OBEN-MERK !
      OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN !
      XY-PROC END_IF
    END_IF
  ;

( -1 IAM1X ! -1 IAM1Y ! -1 IAM2X ! -1 IAM2Y ! 
( OBEN-ABGESCHICKT @ OBEN-MERK ! 
( OBEN-ABGESCHICKT @ OBEN-ANGEKOMMEN ! 
( LINKS-ABGESCHICKT @ LINKS-MERK !
( LINKS-ABGESCHICKT @ LINKS-ANGEKOMMEN !
( UNTEN-ANGEKOMMEN @ UNTEN-MERK ! 
( RECHTS-ANGEKOMMEN @ RECHTS-MERK !
( LINKS-ABGESCHICKT ? LINKS-MERK ? OBEN-ABGESCHICKT ? OBEN-MERK ? RECHTS-ANGEKOMMEN ? RECHTS-MERK ? UNTEN-ANGEKOMMEN ? UNTEN-MERK ?
( 0 0 XY-PROC
( LINKS-ABGESCHICKT ? LINKS-ANGEKOMMEN ?
( L-AUSLES
( LINKS-ABGESCHICKT ? LINKS-ANGEKOMMEN ?
( L-AUSLES
( LINKS-ABGESCHICKT ? LINKS-ANGEKOMMEN ?
( L-AUSLES
( LINKS-ABGESCHICKT ? LINKS-ANGEKOMMEN ?
 
( OBEN-ABGESCHICKT ? OBEN-ANGEKOMMEN ?
( O-AUSLES
( OBEN-ABGESCHICKT ? OBEN-ANGEKOMMEN ?
( O-AUSLES
( OBEN-ABGESCHICKT ? OBEN-ANGEKOMMEN ?
( O-AUSLES
( OBEN-ABGESCHICKT ? OBEN-ANGEKOMMEN ?


BEFESTIGE L-AUSLES
BEFESTIGE O-AUSLES

( 0 0 XY-PROC 
( IAM1X ? IAM1Y ? IAM2X ? IAM2Y ?
</sekt>

<sekt inhalt="in den Zustand für Step_12 bringen und wieder RAM generieren">

( allerdings beim Compilieren von großen ganzen Zahlen im Moment noch 1234 ERROR


111111111111111 DUP * .

( an der Stelle Programm-VHDL-Quelltext für Step_12 ausgeben )
HEX INIT 
HERE 0 0 DUMPZ           ( generiert progRAM für P20_FFP.vhd Step_11
BZEIG @ BANF @ -1 DUMPZ  ( generiert byteRAM für P20_FFP.vhd Step_11
3000 2C00 0 DUMPZ        ( generiert stapR   für P20_FFP.vhd Step_11
</sekt>

<sekt inhalt="noch ein wenig DEMO">
111111111111111 DUP * .

( jetzt eine Matrix invertieren )

DECIMAL

[ [ 1 1 ^ 1 2 ^ 1 3 ^ 1 1 ^ ]
  [ 2 1 ^ 2 2 ^ 2 3 ^ 2 4 ^ ]
  [ 3 1 ^ 3 2 ^ 3 3 ^ 3 4 ^ ]
  [ 4 1 ^ 4 2 ^ 4 3 ^ 4 4 ^ ]
  ] 
DUP .
4 INVERTIEREN ( mat dim --> invmat nenner )
OVER .
DUP .
( Ergebnis sollte sein: OVER .      )
(      [ [ 1152 -864 384 -72 ]      )
(        [ -1248 1368 -672 132 ]    )
(        [ 432 -576 336 -72 ]       )
(        [ -48 72 -48 12 ] ] ok     )
( und gemeinsamer Nenner: DUP . 288 )
</sekt>

</FFINIT2>
</INIT>
