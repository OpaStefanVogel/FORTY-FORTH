<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="R00.xsl" ?>
<los>mehr Speicher

Bisher je 16 Byte Programmspeicher und Rückkehrstapel werden ersetzt durch

Adresse     Datenbreite in Bit   Verwendung
0000-1FFF         16             Programm- und Datenspeicher
2C00-2FFF         16             Rückkehrstapel und Daten
E000-FFFF          8             Textspeicher (nur Bytes)
D001              16             Lesen und Setzen von SP
D002              16             Lesen und Setzen von RP
D003              16             Lesen und Setzen von PC

Dafür sind umfangreiche Ergänzungen des Programms notwendig, es ist aber immer wieder das gleiche Prinzip: Adress- ADR und Datenausgang DAT werden unverändert auf Adress- und Schreibeingang der Speicher-Arrays gelegt, Die Schreibaufforderung WE verzweigt abhängig von ADR zum zugehörigen Array und die Lesedaten aus den Arrays werden abhängig von ADR mit DAT_I zusammengeführt.

!  ( n adr--> ) schreibt n auf Adresse adr
@  ( adr --> n ) liest n von Adresse adr

Die momentane Variante von "@" hat eine Einschränkung: Nach "!" darf nicht unmittelbar gleich "@" folgen. Da diese Konstellation aber bis jetzt kaum aufgetreten ist, habe ich es bisher bei dieser Variante belassen.

Beispielprogramm <i></i>
<table border="1"><tr><th>PC</th><th>PD</th><th>FORTH-Notation</th><th>Stapelinhalt</th><th>SP</th></tr>
  <tr><td>0000</td><td>0100</td><td>BEGIN 0100</td><td>0100</td><td>1</td></tr>
  <tr><td>0001</td><td>4007</td><td>7 EXECUTE</td><td></td><td>0</td></tr>
  <tr><td>0002</td><td>2D00</td><td>2D00</td><td>2D00</td><td>1</td></tr>
  <tr><td>0003</td><td>4007</td><td>7 EXECUTE</td><td></td><td>0</td></tr>
  <tr><td>0004</td><td>E100</td><td>E100</td><td>E100</td><td>1</td></tr>
  <tr><td>0005</td><td>4007</td><td>7 EXECUTE</td><td></td><td>0</td></tr>
  <tr><td>0006</td><td>8FF9</td><td>AGAIN</td><td>1200</td><td>0</td></tr>

  <tr><td>0007</td><td>B501</td><td>DUP</td><td>0100 0100</td><td>2</td></tr>
  <tr><td>0008</td><td>FFFF</td><td>FFFF</td><td>0100 0100 FFFF</td><td>3</td></tr>
  <tr><td>0009</td><td>400F</td><td>0F EXECUTE</td><td>0100</td><td>1</td></tr>
  <tr><td>000A</td><td>B501</td><td>DUP</td><td>0100 0100</td><td>2</td></tr>
  <tr><td>000B</td><td>0000</td><td>0000</td><td>0100 0100 0000</td><td>3</td></tr>
  <tr><td>000C</td><td>400F</td><td>0F EXECUTE</td><td>0100</td><td>1</td></tr>
  <tr><td>000D</td><td>B300</td><td>DROP</td><td></td><td>0</td></tr>
  <tr><td>000E</td><td>A003</td><td>RETURN</td><td></td><td>0</td></tr>

  <tr><td>000F</td><td>B502</td><td>OVER</td><td>0100 0100 FFFF 0100</td><td>4</td></tr>
  <tr><td>0010</td><td>A009</td><td>!</td>0100 0100<td>2</td><td>2</td></tr>
  <tr><td>0011</td><td>8000</td><td>NOOP</td><td>0100 0100</td><td>2</td></tr>
  <tr><td>0012</td><td>A00A</td><td>@</td><td>0100 FFFF</td><td>2</td></tr>
  <tr><td>0013</td><td>2D04</td><td>2D04</td><td>0100 FFFF 2D04</td><td>3</td></tr>
  <tr><td>0014</td><td>A009</td><td>!</td><td>0100</td><td>1</td></tr>
  <tr><td>0015</td><td>A003</td><td>RETURN</td><td>0100</td><td>1</td></tr>
  </table>LEDS ist wieder an Ausgabeadresse 2D04 angeschlossen. Jede der neu verwendbaren Speicheradressen 0100, 2D00 und E100 wird je einmal mit FFFF beschrieben und einmal mit 0000. Jedesmal gleich wieder ausgelesen und das Ergebnis auf Adresse 2D04 ausgegeben, um zu sehen, ob das Umspeichern auf die verschiedenen Werte FFFF und 0000 funktioniert hat. Das erfolgt alles im Unterprogramm ab Adresse 7, welches ein weiteres Unterprogramm ab Adresse 000F aufruft. 
 
<term>your-repo$ git checkout Step_8
your-repo$ git diff Step_7 Step_8</term>
<term>Tcl Console: close_sim
Tcl Console: launch_simulation
Tcl Console: run 1500 ns</term><favicon/> Ergebnis: 
ab Zeitpunkt in ns     LEDS,
       0                UU 
     230                FF
     430                00
     710                FF
     910                00
    1190                FF
    1390                00
   
   

Weiter mit <a href="R09_EMIT">R09 EMIT</a>.

</los>
